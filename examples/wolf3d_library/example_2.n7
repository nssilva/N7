' Wolf3D - Example 2
' ------------------
' Here we use textured floor and ceiling, cover the world in fog and add strafing to the controls.
' These are the new Wolf3D functions introduced:
'   SetFloorTexture(texture)
'   SetCeilingTexture(texture)
'   SetFloorTextureAt(x, y, texture)
'   SetCeilingTextureAt(x, y, texture)
'   SetFog(min_d, max_d, r, g, b)


' Include the library.
include "wolf3d.n7"

' Hide console window.
#win32

' The only function in the library is Wolf3D(). It returns an object (table) that contains all the
' functions and data we need.
w3d = Wolf3D()

' Create window and turn off automatic redraw.
set window "Wolf3D", 320, 240, false, 3
set redraw off

' Load two different wall images.
brickWallImage = loadimage("assets/brick_wall.png")
smileyWallImage = loadimage("assets/brick_wall_smiley.png")
floorImage = loadimage("assets/floor.png")
manholeImage = loadimage("assets/manhole.png")
ceilingImage = loadimage("assets/ceiling.png")
crucifixImage = loadimage("assets/crucifix.png")

' Currently, there is no map editor for the library. So here we let a 2D array define a map. The
' rows in the array represent the x-axis (west to east), and the columns the z-axis (north to
' south). This is what the numbers in the array mean:
'   0 - Empty
'   1 - Brick wall (brickWallImage)
'   2 - Brick wall with a smiley painted on it (smileyWallImage)
'   3 - Floor with a manhole (manholeImage)
'   9 - The player's starting position
map = [
    [1, 1, 1, 1, 1, 1, 2, 1, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 1],
    [2, 0, 9, 0, 0, 0, 3, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 2, 0, 0, 0, 1],
    [1, 0, 3, 0, 1, 0, 3, 0, 2],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 2, 1, 1, 1, 1, 1, 1, 1]]
    
' Now we initialize a map in our w3d object using the function InitMap(map_x_size, map_z_size).
w3d.InitMap(9, 9)
' The library has now created its internal representation of a map containing 9x9 cubes in the XZ
' plane. Each cube has the width, height and depth 1. To each cube we can assign a wall texture,
' floor texture and a ceiling texture. If we assign a wall texture to a cube, the cube becomes a
' solid obstacle with the texture applied to all its faces. If we assign a floor texture,
' the texture is painted on the ground under the cube. And if we assign a ceiling texture, it is
' painted on the ceiling above the cube. Of course, if a cube has a wall texture, you can't see the
' its floor or ceiling texture.
'    Wee can use SetFloorTexture(texture) and SetCeilingTexture(texture) to cover the entire floor
' and ceiling with a texture.
w3d.SetFloorTexture(floorImage)
w3d.SetCeilingTexture(ceilingImage)
' Now, use our map array to set up the map in the w3d object.
for z = 0 to 8
    for x = 0 to 8
        ' Use 'select' to handle the differnt values in our map array.
        select map[z][x]
            case 1 ' Brick wall.
                ' Use SetWall(x, z, texture) to set the wall texture of a cube.
                w3d.SetWall(x, z, brickWallImage)
            case 2 ' Brick wall with a smiley painted on it.
                w3d.SetWall(x, z, smileyWallImage)
            case 3 ' Floor with a manhole.
                ' Use SetFloorTextureAt(x, y, texture) to set the floor texture of a cube. There is
                ' also a SetCeilingTextureAt function for setting the ceiling texture.
                w3d.SetFloorTextureAt(x, z, manholeImage)
            case 9 ' The player's starting position.
                ' Add 0.5 to the x and z coordinates to put the player at the center of the cube.
                playerX = x + 0.5
                playerZ = z + 0.5
        endsel
    next
next

' Before we enter the game loop, we have to call SetView(x, y, w, h, fov) to set the rendering area
' and the fov (field of view). In most cases, like now, we want the rendering area to be the entire
' window. A "good" fov is 70 degrees, but SetView expects the angle in radians, so we use the rad
' function for the conversion.
w3d.SetView(0, 0, width(primary), height(primary), rad(70))

' SetFog(min_d, max_d, r, g, b) creates a fog effect with the color r, g, b. min_d is the distance,
' from the view point, where the fog starts. max_d is the distance at which nothing can be seen but
' the fog color. max_d also serves as a clipping plane - beyond that distance nothing will be
' rendered.
w3d.SetFog(1.5, 4, 16, 32, 24)

' The user will be able to turn around using the arrow keys, so we store the current viewing angle
' in playerAngle.
playerAngle = 0

' Now we're ready to go. Let's loop until the user presses the escape key.
while not keydown(KEY_ESCAPE)
    ' Wanted player movement.
    dx = 0
    dz = 0

    ' Is control pressed?
    if keydown(KEY_CONTROL)
        ' Strafe with the arrow left and right keys.
        if keydown(KEY_LEFT)
            ' To strafe left, subtract 90 degrees from the angle
            dx = dx + cos(rad(playerAngle - 90))
            dz = dz + sin(rad(playerAngle - 90))
        endif
        if keydown(KEY_RIGHT)
            ' To strafe right, add 90 degrees to the angle
            dx = dx + cos(rad(playerAngle + 90))
            dz = dz + sin(rad(playerAngle + 90))
        endif
    else
        ' Rotate view using the arrow left and right keys, use %360 to keep playerAngle in the range
        ' [0..360].
        if keydown(KEY_LEFT)  playerAngle = (playerAngle - 2)%360
        if keydown(KEY_RIGHT) playerAngle = (playerAngle + 2)%360
    endif
    
    ' Move forward with the arrow up key.
    if keydown(KEY_UP)
        ' Use cos of playerAngle to calculate the wanted direction along the x axis and sin for the
        ' z axis. 
        dx = dx + cos(rad(playerAngle))
        dz = dz + sin(rad(playerAngle))
    endif
    ' Move backward with the arrow down key, just use the negative cos and sin values compared to
    ' when moving forward.
    if keydown(KEY_DOWN)
        dx = dx - cos(rad(playerAngle))
        dz = dz - sin(rad(playerAngle))
    endif

    ' Calculate the length of the vector (dx dz).
    d = sqr(dx*dx + dz*dz)
    ' Any movement?
    if d > 0
        ' Normalize the movement vector (make its length 1) by dividing it with its length.
        dx = dx/d
        dz = dz/d
        ' We don't want the player to move an entire cube side length (1) per tick. 0.05 is a more
        ' appropriate speed.
        dx = dx*0.05
        dz = dz*0.05
        
        ' The Move(x, z, dx, dz, min_distance) tries to move a point at the position (x, z) to a new
        ' position (x + dz, z + dz). The function handles collisions with walls and returns the new
        ' position in an object (table) with the fields x and z. min_distance is the minimum allowed
        ' distance to a wall (the point will be "pushed out" this far during collision). 0.25 is a
        ' good min_distance value for the player
        result = w3d.Move(playerX, playerZ, dx, dz, 0.25)
        playerX = result.x
        playerZ = result.z
    endif

    ' The function Render(view_x, view_z, view_angle) renders the "world" as seen from the position
    ' (view_x, view_z) looking in the angle view_angle in the XZ plane. The function expects the
    ' angle to be in radians.
    w3d.Render(playerX, playerZ, rad(playerAngle))

    ' Write instructions
    set color 255, 255, 255
    set caret width(primary)/2, 4
    center "Move and turn with the arrow keys"
    center "Hold Ctrl to strafe instead of turning"
    center "Press Esc to quit"

    ' Update the window.
    redraw
    fwait 60
wend
