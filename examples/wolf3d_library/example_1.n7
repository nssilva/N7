' Wolf3D - Example 1
' ------------------
' In this example we create a small map in which the player can move around. These are the Wolf3D
' functions covered:
'    InitMap(size_x, size_z )
'    SetWall(x, z, texture)
'    SetFloorColor(r, g, b)
'    SetCeilingColor(r, g, b)
'    SetView(x, y, w, h, fov)
'    Move(x, z, dx, dz, min_distance)
'    Render(view_x, view_z, view_angle)


' Include the library.
include "wolf3d.n7"

' Hide console window.
#win32

' The only function in the library is Wolf3D(). It returns an object (table) that contains all the
' functions and data we need.
w3d = Wolf3D()

' Create window and turn off automatic redraw.
set window "Wolf3D", 320, 240, false, 3
set redraw off

' Load two different wall images.
brickWallImage = loadimage("assets/brick_wall.png")
smileyWallImage = loadimage("assets/brick_wall_smiley.png")

' Currently, there is no map editor for the library. So here we let a 2D array define a map. The
' rows in the array represent the x-axis (west to east), and the columns the z-axis (north to
' south). This is what the numbers in the array mean:
'   0 - Empty
'   1 - Brick wall (brickWallImage)
'   2 - Brick wall with a smiley painted on it (smileyWallImage)
'   9 - The player's starting position
map = [
    [1, 1, 1, 1, 1, 1, 2, 1, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 1],
    [2, 0, 9, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 2, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 0, 0, 0, 2],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 2, 1, 1, 1, 1, 1, 1, 1]]
    
' Now we initialize a map in our w3d object using the function InitMap(size_x, size_z).
w3d.InitMap(9, 9)
' The library has now created its internal representation of a map containing 9x9 cubes in the XZ
' plane. Each cube has the width, height and depth 1. To each cube we can assign a wall texture,
' floor texture and a ceiling texture. If we assign a wall texture to a cube, the cube becomes a
' solid obstacle with the texture applied to all its faces. If we assign a floor texture,
' the texture is painted on the ground under the cube. And if we assign a ceiling texture, it is
' painted on the ceiling above the cube. Of course, if a cube has a wall texture, you can't see the
' its floor or ceiling texture.
'    So, let's use our map array to set up the map in the w3d object.
for z = 0 to 8
    for x = 0 to 8
        ' Use 'select' to handle the differnt values in our map array.
        select map[z][x]
            case 1 ' Brick wall.
                ' Use SetWall(x, z, texture) to set the wall texture of a cube.
                w3d.SetWall(x, z, brickWallImage)
            case 2 ' Brick wall with a smiley painted on it.
                w3d.SetWall(x, z, smileyWallImage)
            case 9 ' The player's starting position.
                ' Add 0.5 to the x and z coordinates to put the player at the center of the cube.
                playerX = x + 0.5
                playerZ = z + 0.5
        endsel
    next
next

' We have not loaded any floor or ceiling images. But we can use the functions SetFloorColor and
' SetCeilingColor to paint the entire floor and ceiling in solid colors. Let's make the floor green
' and the ceiling blue.
w3d.SetFloorColor(16, 64, 16)
w3d.SetCeilingColor(32, 64, 208)

' Before we enter the game loop, we have to call SetView(x, y, w, h, fov) to set the rendering area
' and the fov (field of view). In most cases, like now, we want the rendering area to be the entire
' window. A "good" fov is 70 degrees, but SetView expects the angle in radians, so we use the rad
' function for the conversion.
w3d.SetView(0, 0, width(primary), height(primary), rad(70))

' The user will be able to turn around using the arrow keys, so we store the current viewing angle
' in playerAngle.
playerAngle = 0

' Now we're ready to go. Let's loop until the user presses the escape key.
while not keydown(KEY_ESCAPE)
    ' Rotate view using the arrow left and right keys, use %360 to keep playerAngle in the range
    ' [0..360].
    if keydown(KEY_LEFT)  playerAngle = (playerAngle - 2)%360
    if keydown(KEY_RIGHT) playerAngle = (playerAngle + 2)%360
    
    ' Wanted player movement.
    dx = 0
    dz = 0
    
    ' Move forward with the arrow up key.
    if keydown(KEY_UP)
        ' Use cos of playerAngle to calculate the wanted direction along the x axis and sin for the
        ' z axis. 
        dx = dx + cos(rad(playerAngle))
        dz = dz + sin(rad(playerAngle))
    endif
    ' Move backward with the arrow down key, just use the negative cos and sin values compared to
    ' when moving forward.
    if keydown(KEY_DOWN)
        dx = dx - cos(rad(playerAngle))
        dz = dz - sin(rad(playerAngle))
    endif

    ' Calculate the length of the vector (dx dz). This might feel a bit "overkill" since it will 
    ' always be either 1 or 0 in this example.
    d = sqr(dx*dx + dz*dz)
    ' Any movement?
    if d > 0
        ' This may also seem like overkill here. We really don't need to normalize the vector
        ' (dx dz), since we already know that it has the length 1 (a normalized vector is a vector
        ' with the length 1, and (cos(a) sin(a)) is always normalized). But it will make more sense
        ' when we add strafing in the next example. To normalize a vector you divide it with its
        ' length (d).
        dx = dx/d
        dz = dz/d
        ' We don't want the player to move an entire cube side length (1) per tick. 0.05 is a more
        ' appropriate speed.
        dx = dx*0.05
        dz = dz*0.05
        
        ' The Move(x, z, dx, dz, min_distance) tries to move a point at the position (x, z) to a new
        ' position (x + dz, z + dz). The function handles collisions with walls and returns the new
        ' position in an object (table) with the fields x and z. min_distance is the minimum allowed
        ' distance to a wall (the point will be "pushed out" this far during collision). 0.25 is a
        ' good min_distance value for the player
        result = w3d.Move(playerX, playerZ, dx, dz, 0.25)
        playerX = result.x
        playerZ = result.z
    endif

    ' The function Render(view_x, view_z, view_angle) renders the "world" as seen from the position
    ' (view_x, view_z) looking in the angle view_angle in the XZ plane. The function expects the
    ' angle to be in radians.
    w3d.Render(playerX, playerZ, rad(playerAngle))
    
    ' Write instructions
    set color 255, 255, 255
    set caret width(primary)/2, 4
    center "Move and turn with the arrow keys"
    center "Press Esc to quit"

    ' Update the window.
    redraw
    fwait 60
wend
