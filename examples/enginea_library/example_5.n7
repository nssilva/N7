' example_5.n7
' ------------

include "enginea.n7"

' A list of open doors, for automatic closing.
visible vOpenDoors = []

' Sprite images.
visible vRubyImage, vDiamondImage, vHeartImage, vChestImage
visible vPumpkinImage

' Number of collected items.
visible vRubies = 0, vDiamonds = 0, vHearts = 0, vChests = 0

' Set up a fullscreen window with the same aspect ratio as the screen.
set window "Example 5", 320, 240, false, 2
'set window "Example 5", 240*screenw()/screenh(), 240, true, 2
set redraw off

' Use EA_SetView(target_image, fov, z_min, z_max) to set up the renderer.
EA_SetView(primary, rad(76), 0.05, 6)

' Load sprite images.
vRubyImage = loadimage("assets/ruby.png")
vDiamondImage = loadimage("assets/diamond.png")
vHeartImage = loadimage("assets/heart.png")
vChestImage = loadimage("assets/chest.png")
' This image has two row with 4 cels, but the second row isn't used until the next example.
vPumpkinImage = loadimage("assets/pumpkin.png", 4, 2)

' Use EA_LoadMap(filename) to load a map created with the EngineA editor.
flags = EA_LoadMap("assets/map_5.json")
assert typeof(flags), "Map could not be loaded"

' Look for the flag "player".
player = unset
foreach f in flags
    select f.flag
        case "player"
            player = EA_FpsPlayer()
            player.SetPos(f.x, f.floorY, f.z)
            ' SetLeap sets a height that the player can leap up to automatically without jumping.
            player.SetLeap(0.25)
            ' SetHeight sets the player's height. It defaults to 0.5.
            player.SetHeight(0.6)
            ' SetEye sets the height of the player's eyes, default is 0.5.
            player.SetEye(0.5)
            ' Set the movement speed, defaults to 1.
            player.SetMoveSpeed(1.5)
        case "ruby"
            ' Use a helper function, CreateItem, implemented later. It creates a sprite (static
            ' object) from the specified image.
            o = CreateItem(vRubyImage, f.x, f.floorY, f.z)
            EA_AddStaticObject(o)
        case "diamond"
            o = CreateItem(vDiamondImage, f.x, f.floorY, f.z)
            EA_AddStaticObject(o)
        case "heart"
            o = CreateItem(vHeartImage, f.x, f.floorY, f.z)
            EA_AddStaticObject(o)
        case "chest"
            o = CreateItem(vChestImage, f.x, f.floorY, f.z)
            EA_AddStaticObject(o)
        case "pumpkin"
            o = CreatePumpkinEnemy(f.x, f.floorY, f.z)
            EA_AddObject(o)
    endsel
next
assert typeof(player), "No player flag found"
        
' Add the player object and set it to be the camera.
EA_AddObject(player)
EA_SetCamera(player)

' Set an update callback for the player. This function will be called once every frame.
player.Update = function(dt)
    ' Open doors with the F key.
    if keydown(KEY_F, true)
        ' Facing returns an object with lots of information about the closest "wall" in the direction
        ' that the player is looking. It may return an unset variable if the player is looking on the
        ' floor or the ceiling. So start by making sure that res has a value with "if res ...". For now
        ' we're only interested in doors, so next check the type field. If it's a door, type is EA_DOOR.
        ' The last thing we need to check is how far away the door is. For that we can use the dist
        ' field. If the distance is less than 1 unit, the player may open the door.
        res = .Facing()
        if res and res.type = EA_DOOR and res.dist < 1
            ' Since type is EA_DOOR, res.data contains a door object. We can use its Open function
            ' to open the door. It returns true if the door isn't already open/opening.
            if res.data.Open()
                ' Put the door at the end of the vOpenDoors array.
                vOpenDoors[sizeof(vOpenDoors)] = res.data
                ' And add a timer field to the door object and set it to 3 (seconds).
                res.data.timer = 3
            endif
        endif
    endif
    
    ' Pick up items. Every object can call its SectorObjects function to get an array of all the
    ' objects in its current sector. The returned value may be an unset variable, so check for that
    ' first, then its size.
    objs = .SectorObjects()
    if objs and sizeof(objs)
        for i = 0 to sizeof(objs) - 1
            ' Use CollidesWith(obj) to check if the player collides (overlaps) with this object.
            if .CollidesWith(objs[i])
                ' Use the sprite image to determine what type of object it is.
                select objs[i].Sprite()
                    case vRubyImage
                        vRubies = vRubies + 1
                        EA_RemoveObject(objs[i])
                    case vDiamondImage
                        vDiamonds = vDiamonds + 1
                        EA_RemoveObject(objs[i])
                    case vHeartImage
                        vHearts = vHearts + 1
                        EA_RemoveObject(objs[i])
                    case vChestImage
                        vRubies = vRubies + 10
                        vDiamonds = vDiamonds + 5
                        vHearts = vHearts + 1
                        EA_RemoveObject(objs[i])
                endsel
            endif
        next
    endif
endfunc

' Use SetMouseSens to change the mouse sensitivity of the player object so that it suits your
' setup.
player.SetMouseSens(0.75)

' Tell EA to use Update as update function.
EA_SetUpdateAction(Update)

' Tell EA to use Draw as draw function.
EA_SetDrawAction(Draw)

' Enable fog effect with EA_SetFog(mode, r, g, b), where mode can be EA_RETRO or EA_NORMAL.
EA_SetFog(EA_NORMAL, 0, 4, 16)

' Enter game loop.
EA_Run()

' Update callback, called by EA once every frame.
function Update(dt)
    if keydown(KEY_ESCAPE, true)  EA_Stop()
    
    ' Update the open doors.
    i = 0
    while i < sizeof(vOpenDoors)
        d = vOpenDoors[i]
        ' Close the door and remove it from the array when its timer reaches 0.
        d.timer = d.timer - dt
        if d.timer <= 0
            d.Close()
            free key vOpenDoors, i
        else
            i = i + 1
        endif
    wend
endfunc

' Draw function, called by EA when it has rendered the scene.
function Draw()
    ' Draw number of rubies, diamonds and hearts collected.
    set color 255, 255, 255
    draw image vRubyImage, 4, 4
    draw image vDiamondImage, 4, 28
    draw image vHeartImage, 4, 52
    set caret 32, 8
    wln vRubies
    set caret 32, 32
    wln vDiamonds
    set caret 32, 56
    wln vHearts
endfunc

' Create and return a sprite, static object, using the image img.
function CreateItem(img, x, y, z)
    ' A static object is a sprite or mesh that can't be moved after being added to the engine. It
    ' can be assigned an Update function and hence be animated, and it can be removed. It can also
    ' be assigned a collision polygon, so that it becomes an obstacle that non-static object can
    ' bump into and even stand on. This function is used for creating items that the player can
    ' pick up though.
    item = EA_StaticObject()
    ' Use SetSprite(img_id, cel, onlyYaw) to set the image. onlyYaw means that the sprite will
    ' always face the camera but only be rotated around the y axis, which is good for this kind of
    ' objects. If onlyYaw is set to false, the sprite will also be rotated around the x axis to 
    ' completely face the camera.
    item.SetSprite(img, 0, true)
    ' A unit sized wall in these examples is 64x64 pixels large. To make the pixel density
    ' consistent, we therefor calculate the sprite's size by dividing its pixel size with 64. 
    item.SetHeight(height(img)/64)
    item.SetRadius(0.5*width(img)/64)
    ' Set position with SetPos(x, y, z)
    item.SetPos(x, y, z)
    
    return item
endfunc

' Create and return a pumpkin enemy.
function CreatePumpkinEnemy(x, y, z)
    ' The object returned by EA_FpsPlayer (used for the player) is based on a regular object
    ' returned by EA_Object. For enemies, bullets etc, we have to implement lots of functionality
    ' ourselves.
    enemy = EA_Object()
    ' There's no difference between SetSprite for a static object and a regular object.
    enemy.SetSprite(vPumpkinImage, 0, true)
    ' Nor is there any difference in SetHeight, SetRadius or SetPosition, so I'm using the same
    ' logic as in CreateItem.
    enemy.SetHeight(height(vPumpkinImage)/64)
    enemy.SetRadius(0.5*width(vPumpkinImage)/64)
    enemy.SetPos(x, y, z)
    ' Give the enemy a random starting direction with SetYaw(radians). We'll use the the direction
    ' given by yaw to move the enemy.
    enemy.SetYaw(rad(rnd(360)))
    
    ' We need to control the animation of the enemy, so let's add a cel field.
    enemy.cel = 0
    
    ' In the Update function of the enemy, we'll animate it and make it change direction whenever it
    ' bumps into a wall.
    enemy.Update = function(dt)
        ' Let's start with the simple stuff, the animation of the enemy. It has four frames, and
        ' we want to display them all 2 times during a time period of 1s and then start over, so:
        .cel = (.cel + dt*8)%4
        ' Then we call the object function SetCel to actually set the cel for the sprite.
        .SetCel(int(.cel))
        
        ' The object function Move(dx, dy, dz, leap) TRIES to move the object in the direction
        ' (dx dy dz). The last parameter, leap, let's the object auto-leap over heights <= leap
        ' units (EA_FpsPlayer uses this function with the leap value set with SetLeap). It returns
        ' an object with lots of information about how it went. We use the object functions DX and
        ' DZ that returns the direction based on the object's yaw angle. There's also a DY function,
        ' but it's only relevant if you also use SetPitch, which we don't for now. The pumpkin enemy
        ' should move 0.75 units per second. We set dy to 1*dt, which will serve as very primitive
        ' gravity (linear movement, 1 unit/s vertically). We use the same leap value as we do for
        ' the player.
        res = .Move(.DX()*0.75*dt, 1*dt, .DZ()*0.75*dt, 0.25)
        ' As I said, the object that Move returns, contains lots of information. You can use it to
        ' tell what type of wall or static object the object bumped into. But for now, we just need
        ' to know if the enemy ran into a wall, and we know it did if res.w (w for wall) is true.
        if res.w
            ' So, what to do when the enemy has hit a wall? We could just give it a new completely
            ' random direction (yaw angle). But, it would be stupid to send him straight into the
            ' wall again. res.dx and res.dz contains the normal of the wall/static object that the
            ' enemy bumped into. The normal is a vector perpendicular to the wall. We can use atan2
            ' to convert that normal into an angle (in radians). Then we add a random 180 degrees
            ' to that angle:
            .SetYaw(rad(deg(atan2(res.dx, res.dz)) - 90 + rnd()*180))
        endif
    endfunc
    
    return enemy
endfunc
