' Breakthrough - step 4
' ---------------------
' Spawn and pick up simple powerups based on game flags set in the tilemap editor.
'
' Graphics by pudman: https://opengameart.org/content/arkanoid-assets


include "tilemap.n7"

#win32

' Powerup types.
constant BIG_PADDLE = 1, SMALL_PADDLE = 2

' An array of power up sprites, spawned in the BreakBrick function.
visible vPowerups = []

' Images.
visible vPowerupBigImage, vPowerupSmallImage

' Create a window with a weird size.
set window "Breakthrough", 737, 737*9/16
set redraw off

' Load images.
smallPaddleImage = loadimage("assets/small_paddle.png")
mediumPaddleImage = loadimage("assets/paddle.png")
largePaddleImage = loadimage("assets/large_paddle.png")

ballImage = loadimage("assets/ball.png")
vPowerupBigImage = loadimage("assets/powerup_big.png")
vPowerupSmallImage = loadimage("assets/powerup_small.png")

' Create and set a font.
set font createfont("arial", 28, true, false, false, true)

' Load a map created with the tilemap editor.
if not TM_LoadMap("assets/level1.txt")  end

' Tell the library that the bottom of the map should not be treated as an obstacle. When the ball
' leaves the screen, we exit the game loop (for now).
TM_SetBorder(true, true, true, false)

' Set up the rendering view for the library. Usually this is what you want, the top left corner of
' the window (0, 0) and the same width and height.
TM_SetView(0, 0, width(primary), height(primary))

' Start with medium paddle.
paddleImage = mediumPaddleImage

' Y-coordinate of paddle.
paddleY = height(primary) - height(paddleImage)*3

' Create a ball sprite.
ball = [
    ' Image.
    img: ballImage,
    ' Position.
    x: (width(primary) - width(ballImage))/2, y: paddleY - height(ballImage),
    ' Size.
    w: width(ballImage), h: height(ballImage),
    ' Direction.
    dx: cos(rad(330)), dy: sin(rad(330)),
    ' Speed.
    spd: 4]

' A list where we put items that should be removed from other lists.
remove = []

' Loop until escape key is pressed.
while not (keydown(KEY_ESCAPE, true) or ball.y > height(primary))
    ' Update center x coordinate of paddle.
    paddleX = mousex() - width(paddleImage)/2

    ' Move the ball.
    TM_MoveSprite(ball, ball.dx*ball.spd, ball.dy*ball.spd)
    ' Bounce and break bricks on collision.
    if TM_CollisionUp()
        ' Call BreakBrick (defined below the game loop) to check if there's a brick at the top left
        ' and top right corners of the ball.
        BreakBrick(ball.x, ball.y + ball.dy)
        BreakBrick(ball.x + ball.w, ball.y + ball.dy)
        ' Invert y direction.
        ball.dy = -ball.dy
    elseif TM_CollisionDown()
        ' Break bricks bottom left/right.
        BreakBrick(ball.x, ball.y + ball.h + ball.dy)
        BreakBrick(ball.x + ball.w, ball.y + ball.h + ball.dy)
        ball.dy = -ball.dy
    endif
    if TM_CollisionLeft()
        ' Break bricks top/bottom left.
        BreakBrick(ball.x + ball.dx, ball.y)
        BreakBrick(ball.x + ball.dx, ball.y + ball.h)
        ball.dx = -ball.dx
    elseif TM_CollisionRight()
        ' Break bricks top/bottom right.
        BreakBrick(ball.x + ball.w + ball.dx, ball.y)
        BreakBrick(ball.x + ball.w + ball.dx, ball.y + ball.h)
        ball.dx = -ball.dx
    endif

    ' Check if ball and paddle overlap if ball is on its way down.
    if ball.dy > 0 and TM_ImagesCollide(ball.img, ball.x, ball.y, paddleImage, paddleX, paddleY)
        ' Calculate a new direction based on the horizontal distance betwen the ball and the centre
        ' of the paddle.
        dx = ball.x + ball.w/2 - (paddleX + width(paddleImage)/2)
        ' Divide with half the width of the paddle + the width of the ball to get a dx value in the
        ' range [-1..1].
        dx = 2*dx/(width(paddleImage) + width(ballImage))
        ' You can play with the dy value set here, to modify the allowed "slope" of the new
        ' direction.
        dy = -0.5
        ' Normalize the vector (dx dy) to the size 1 - the speed is controlled by the spd field of
        ' the ball.
        k = 1/sqr(dx*dx + dy*dy)
        ball.dx = k*dx
        ball.dy = k*dy
    endif

    ' Update powerups.
    clear remove
    foreach p in vPowerups
        if p.Update()
            if TM_ImagesCollide(p.img, p.x, p.y, paddleImage, paddleX, paddleY)
                ' Check type.
                select p.type
                    case BIG_PADDLE
                        ' Change paddle image.
                        if paddleImage = smallPaddleImage  paddleImage = mediumPaddleImage
                        else paddleImage = largePaddleImage
                        ' Update position
                        paddleX = mousex() - width(paddleImage)/2
                    case SMALL_PADDLE
                        if paddleImage = largePaddleImage  paddleImage = mediumPaddleImage
                        else paddleImage = smallPaddleImage
                        paddleX = mousex() - width(paddleImage)/2
                endsel
                remove[sizeof(remove)] = p
            endif
        else
            remove[sizeof(remove)] = p
        endif
    next
    ' Remove powerups that have been put in the remove list.
    foreach p in remove  free val vPowerups, p 

    ' Clear screen.
    set color 95, 95, 95
    cls

    ' Render the tilemap.
    TM_Render()

    ' Draw paddle.
    draw image paddleImage, paddleX, paddleY

    ' Draw powerups.
    foreach p in vPowerups  draw image p.img, p.x, p.y

    ' Draw ball.
    draw image ball.img, ball.x, ball.y

    ' Write a warning.
    set caret width(primary)/2, height(primary) - fheight()*1.5
    center "If you drop the ball, it's all over ..."

    ' Update window content.
    redraw

    fwait 60
wend

' BreakBrick
' ----------
' Remove any brick at the specified position.
function BreakBrick(x, y)
    ' Convert to map (tile) coordinates.
    x = TM_ToMapX(x)
    y = TM_ToMapY(y)
    ' Remove cel (set to -1) if there's a brick.
    if TM_GetCel(x, y) >= 0 TM_SetCel(x, y, -1)

    ' Check if there's a game flag set for this brick.
    flag = TM_GetFlag(x, y)
    if flag
        TM_SetFlag(x, y, unset)
        AddPowerup(flag, x, y)
    endif
endfunc

' AddPowerup
' ----------
' Add power up based on the flag.
function AddPowerup(flag, tileX, tileY)
    ' You can see that game flags are set for some tiles in tilemap editor.
    select flag
        case "big"
            type = BIG_PADDLE
            img = vPowerupBigImage
        case "small"
            type = SMALL_PADDLE
            img = vPowerupSmallImage
        ' Will add more later.
        default
            type = 0
    endsel

    if type
        ' Angle, for the powerup's direction.
        a = rad(225 + rnd(90))
        ' Put at the end of the array.
        vPowerups[sizeof(vPowerups)] = [
            ' Type and image.
            type: type,
            img: img,
            ' Position.
            x: (tileX + 0.5)*TM_TileWidth() - width(img)/2,
            y: (tileY + 0.5)*TM_TileHeight() - height(img)/2,
            ' Size.
            w: width(img), h: height(img),
            ' X and y speed.
            dx: cos(a)*2, dy: sin(a)*2,

            ' Update.
            Update: function()
                ' Move and apply gravity.
                this.x = this.x + this.dx
                this.y = this.y + this.dy
                this.dy = min(this.dy + 0.1, 4.0)
                ' Still within screen?
                if this.y < height(primary)
                    ' Bounce on screen edges.
                    if this.x < 0
                        this.x = 0
                        this.dx = -this.dx*0.5
                    elseif this.x + this.w > width(primary)
                        this.x = width(primary) - this.w
                        this.dx = -this.dx*0.5
                    endif
                    return true
                else
                    return false
                endif
            endfunc
            ]
    endif
endfunc
