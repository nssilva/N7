' ngui
' ----
' By Marcus 2022.
'
' 20250824: Keyboard focus is now released from widget as soon as the user clicks somewhere outside
'           the widget. Earlier, focus was only lost if the used clicked on a new widget that wanted
'           keyboard focus.
'
' Bugs:
'   * Action: Click on a menu item, don't release the mouse button, and press Esc.
'     Result: Menu Action is called with the selected index.
'     Solved: It seems a WM_LBUTTONUP is sent when any keyboard key is pressed if the click came
'             from a touchpad. Can't find information about it anywhere, but ... that seems to be
'             the case, can't do anything about it.


' Auto sizes.
constant SIZE_EXPAND = 0, SIZE_AUTO = -1
' Align.
constant ALIGN_LEFT = -1, ALIGN_CENTER = 0, ALIGN_RIGHT = 1
constant ALIGN_TOP = -1, ALIGN_BOTTOM = 1
' Popup settings
constant POPUP_IGNORE = 0, POPUP_CLOSE = 1
' Tab size for TextEntry and TextEditor. 
constant TAB_SIZE = 4
' History events.
constant ADD_STR = 1, DEL_STR = 2
constant ADD_SEL = 3, DEL_SEL = 4
constant ADD_LIN = 5, DEL_LIN = 6

' Numeric text entry mode.
constant INTEGER = 1, FLOAT = 2

' Colors.
constant COLOR_BACKGROUND =             0
constant COLOR_TEXT =                   1
constant COLOR_PRIMARY_BACKGROUND =     2
constant COLOR_PRIMARY_TEXT =           3
constant COLOR_BORDER =                 4
constant COLOR_LIGHT_BORDER =           5
constant COLOR_MENU_BACKGROUND =        6
constant COLOR_MENU_TEXT =              7
constant COLOR_MENUBAR_BACKGROUND =     8
constant COLOR_MENUBAR_TEXT =           9
constant COLOR_TOOLTIP_BACKGROUND =     10
constant COLOR_TOOLTIP_TEXT =           11
constant COLOR_ED_BACKGROUND =          12
constant COLOR_ED_TEXT =                13
constant COLOR_ED_SELECTION =           14
constant COLOR_SHADOW =                 15
constant COLOR_SH_KEYWORD =             16
constant COLOR_SH_CONSTANT =            17
constant COLOR_SH_STRING =              18
constant COLOR_SH_NUMBER =              19
constant COLOR_SH_COMMENT =             20
constant COLOR_SH_FLAG =                21
constant COLOR_ED_LN_BACKGROUND =       22
constant COLOR_ED_LN_TEXT =             23
constant COLOR_COUNT =                  24

' Built in icons.
constant IMAGE_ARROW_UP =       0
constant IMAGE_ARROW_DOWN =     1
constant IMAGE_ARROW_LEFT =     2
constant IMAGE_ARROW_RIGHT =    3
constant IMAGE_CLOSE =          4
constant IMAGE_CLOSE_SMALL =    5
constant IMAGE_COUNT =          6

' Running flag.
visible vRunning = false
' For mouse effects.
visible vDarken = 0.8
visible vBrighten = 1.2
' Colors.
visible vColors = fill(dim(4), COLOR_COUNT)
visible vColorStack = Stack()
' Images.
visible vImages = [
        CreateArrowUpImage(),
        CreateArrowDownImage(),
        CreateArrowLeftImage(),
        CreateArrowRightImage(),
        CreateCloseImage(),
        CreateSmallCloseImage()]
' Fonts.
visible vDefaultFont
visible vHeaderFont
visible vTextEntryFont
visible vTextEditorFont
'visible vTextEditorCommentFont
' Other settings.
visible vLabelPadding = 2
visible vButtonPadding = 0
visible vTextButtonInnerPadding = 4
visible vCheckBoxSize = 14
visible vRadioButtonSize = 14
visible vCheckBoxPadding = 2
visible vLabledCheckBoxSpacing = 2
visible vMenuItemExtraSpacing = 24
visible vMessageBoxShadow = 9
visible vMenuShadow = 6
visible vComboBoxShadow = 3
visible vTooltipShadow = 3
visible vMessageBoxMinWidth = 100
visible vTooltipDelay = 1000
visible vTabItemSpacing = 12

visible vRoot
visible vPopups = []
visible vTooltip = unset, vVolatileTooltip = false, vTooltipX, vTooltipY, vTooltipW, vTooltipH
visible vKeyboardWdgStack = []
visible vMouseX, vMouseY
visible vLeftMB, vRightMB
visible vMouseOverWdg, vMouseWdg
visible vMouseOverWdgTime = 0
visible vKeyboardWdg
visible vRadioButtonGroups = []
visible vAnyDirty = false
visible vLayoutChanged = false
visible vLayoutSecondPassRequired = false
visible vFps = 20

visible vCommandKeys = []
visible vFunctionKeys = []

visible vWinMsgAction

visible vHexTable = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
        "A", "B", "C", "D", "E", "F"]

SetDarkMode(false)

vDefaultFont =  createfont("calibri", 18, false, false, false, true)
vHeaderFont = createfont("calibri", 22, true, false, false, true)
vTextEntryFont = createfont("consolas", 16, false, false, false, true)
vTextEditorFont = createfont("consolas", 16, false, false, false, true)
'vTextEditorCommentFont = createfont("consolas", 16, false, true, false, true)

' EnterMainLoop
' -------------
function EnterMainLoop(root)
    vRoot = root
    if not vRoot.background  vRoot.background = vColors[COLOR_BACKGROUND]
    vRunning = true
    ClearSize(vRoot)
    vLayoutSecondPassRequired = false
    vRoot.Resize(width(primary), height(primary))
    if vLayoutSecondPassRequired vRoot.Resize(width(primary), height(primary))
    vRoot.Draw(vColors[COLOR_BACKGROUND])
    redraw

    while vRunning
        vAnyDirty = false
        vLayoutChanged = false

        CheckWinMsg()
        
        ' Program lost focus?
        if not active()
            if vKeyboardWdg and typeof(vKeyboardWdg.LostFocus)
                vKeyboardWdg.LostFocus()
                if vAnyDirty  Redraw()
            endif
            ' Sleep until focus is back.
            while not active()
                if CheckWinMsg()  break
                wait 500
            wend
            if vKeyboardWdg and typeof(vKeyboardWdg.GotFocus)  vKeyboardWdg.GotFocus()
        endif

        ' Update mouse and keyboard.
        UpdateMouse()
        UpdateKeyboard()

        ' Any layout changes?
        if vLayoutChanged or vRoot.w <> width(primary) or vRoot.h <> height(primary)            
            ClearSize(vRoot)
            vLayoutSecondPassRequired = false
            vRoot.Resize(width(primary), height(primary))
            if vLayoutSecondPassRequired vRoot.Resize(width(primary), height(primary))
            MarkAllDirty()
        endif
    
        ' Draw?
        if vAnyDirty  Redraw()
    
        fwait vFps
    wend
endfunc

' ClearSize
' ---------
' Clear size of widget and any children.
function ClearSize(wdg)
    wdg.w = 0
    wdg.h = 0
    if wdg.children  foreach child in wdg.children ClearSize(child)
endfunc

' CheckWinMsg
' -----------
' Capture messages from other n7 programs, forward to user action if set.
function CheckWinMsg()
    msg = system("n7:winmsg")
    if msg
        if vWinMsgAction and vWinMsgAction(msg)
            return true
        endif
    endif
    return false
endfunc

' Redraw
' ------
function Redraw()
    ' Only dirty widgets will actually be drawn.
    vRoot.Draw(vColors[COLOR_BACKGROUND])
    if sizeof(vPopups)
        for i = 0 to sizeof(vPopups) - 1 vPopups[i].Draw(vColors[COLOR_BACKGROUND])
    endif
    if vTooltip
        ' Blinking caret causes redraw, which redraws this.
        'if vTooltipShadow and vColors[COLOR_SHADOW]
        '    set color vColors[COLOR_SHADOW]
        '    draw rect vTooltipX + vTooltipShadow, vTooltipY + vTooltipShadow,
        '            vTooltipW, vTooltipH, true
        'endif
        set color vColors[COLOR_TOOLTIP_BACKGROUND]
        draw rect vTooltipX, vTooltipY, vTooltipW, vTooltipH, true
        set color vColors[COLOR_BORDER]
        draw rect vTooltipX, vTooltipY, vTooltipW, vTooltipH, false
        set font vDefaultFont
        set color vColors[COLOR_TOOLTIP_TEXT]
        set caret vTooltipX + 3, vTooltipY + 3
        write vTooltip
    endif
    redraw
endfunc

' GetColor
' --------
' Return color for identifier.
function GetColor(id)
    if id >= 0 and id < COLOR_COUNT  return vColors[id]
    else return unset
endfunc

' SetColor
' --------
' Change a color by identifier.
function SetColor(id, r, g, b)
    SetColorRGB(id, r, g, b)
endfunc

' PushColors
' ----------
function PushColors()
    vColorStack.Add(vColors)
    vColors = copy(vColors)
endfunc

' PopColors
' ---------
function PopColors()
    if typeof(vColorStack.Peek())  vColors = vColorStack.Pop()
endfunc

' SetColorRGB
' -----------
' Change a color by identifier.
function SetColorRGB(id, r, g, b)
    if id >= 0 and id < COLOR_COUNT
        vColors[id][0] = r
        vColors[id][1] = g
        vColors[id][2] = b
        vColors[id][3] = 255
        if vRunning  MarkAllDirty()
    endif
endfunc

' SetColorRGBA
' ------------
' Change a color by identifier.
function SetColorRGBA(id, r, g, b, a)
    if id >= 0 and id < COLOR_COUNT
        vColors[id][0] = r
        vColors[id][1] = g
        vColors[id][2] = b
        vColors[id][3] = a
        if vRunning  MarkAllDirty()
    endif
endfunc

' GetImage
' --------
' Return an image by identifier.
function GetImage(id)
    if id >= 0 and id < IMAGE_COUNT  return vImages[id]
    else return  unset
endfunc

' SetDarkMode
' -----------
' For switching between light and dark mode, two preset themes.
function SetDarkMode(value)
    if value
        SetColorRGB(COLOR_BACKGROUND, 24, 24, 24)
        SetColorRGB(COLOR_TEXT, 232, 232, 232)
        SetColorRGB(COLOR_PRIMARY_BACKGROUND, 64, 96, 112)
        SetColorRGB(COLOR_PRIMARY_TEXT, 232, 232, 232)
        SetColorRGB(COLOR_BORDER, 96, 96, 96)
        SetColorRGB(COLOR_LIGHT_BORDER, 48, 48, 48)
        SetColorRGB(COLOR_MENU_BACKGROUND, 0, 0, 0)
        SetColorRGB(COLOR_MENU_TEXT, 232, 232, 232)
        SetColorRGB(COLOR_MENUBAR_BACKGROUND, 24, 24, 24)
        SetColorRGB(COLOR_MENUBAR_TEXT, 232, 232, 232)
        SetColorRGB(COLOR_TOOLTIP_BACKGROUND, 0, 0, 0)
        SetColorRGB(COLOR_TOOLTIP_TEXT, 232, 232, 232)
        SetColorRGB(COLOR_ED_BACKGROUND, 0, 0, 0)
        SetColorRGB(COLOR_ED_TEXT, 190, 190, 190)
        SetColorRGB(COLOR_ED_SELECTION, 48, 48, 48)
        SetColorRGB(COLOR_ED_LN_BACKGROUND, 24, 24, 24)
        SetColorRGB(COLOR_ED_LN_TEXT, 96, 96, 96)
        SetColorRGBA(COLOR_SHADOW, 0, 0, 0, 32)
    
        SetColorRGB(COLOR_SH_KEYWORD, 203, 169, 100)
        SetColorRGB(COLOR_SH_CONSTANT, 100, 181, 203)
        SetColorRGB(COLOR_SH_STRING, 203, 101, 132)
        SetColorRGB(COLOR_SH_NUMBER, 100, 181, 203)
        SetColorRGB(COLOR_SH_COMMENT, 100, 203, 109)
        SetColorRGB(COLOR_SH_FLAG, 104, 104, 104)  
    else
        SetColorRGB(COLOR_BACKGROUND, 240, 240, 240)
        SetColorRGB(COLOR_TEXT, 0, 0, 0)
        SetColorRGB(COLOR_PRIMARY_BACKGROUND, 64, 112, 224)
        SetColorRGB(COLOR_PRIMARY_TEXT, 255, 255, 255)
        SetColorRGB(COLOR_BORDER, 96, 96, 96)
        SetColorRGB(COLOR_LIGHT_BORDER, 204, 204, 204)
        SetColorRGB(COLOR_MENU_BACKGROUND, 255, 255, 255)
        SetColorRGB(COLOR_MENU_TEXT, 0, 0, 0)        
        SetColorRGB(COLOR_MENUBAR_BACKGROUND, 255, 255, 255)
        SetColorRGB(COLOR_MENUBAR_TEXT, 0, 0, 0)
        SetColorRGB(COLOR_TOOLTIP_BACKGROUND, 255, 255, 224)
        SetColorRGB(COLOR_TOOLTIP_TEXT, 0, 0, 0)
        SetColorRGB(COLOR_ED_BACKGROUND, 255, 255, 255)
        SetColorRGB(COLOR_ED_TEXT, 40, 40, 40)
        SetColorRGB(COLOR_ED_SELECTION, 224, 224, 224)
        SetColorRGBA(COLOR_SHADOW, 0, 0, 0, 32)
        SetColorRGB(COLOR_ED_LN_BACKGROUND, 240, 240, 240)
        SetColorRGB(COLOR_ED_LN_TEXT, 96, 96, 96)

        SetColorRGB(COLOR_SH_KEYWORD, 0, 0, 208)
        SetColorRGB(COLOR_SH_CONSTANT, 208, 0, 184)
        SetColorRGB(COLOR_SH_STRING, 208, 67, 0)
        SetColorRGB(COLOR_SH_NUMBER, 40, 40, 40)
        SetColorRGB(COLOR_SH_COMMENT, 0, 160, 0)
        SetColorRGB(COLOR_SH_FLAG, 128, 128, 128)
    endif
endfunc

' LoadTheme
' ---------
function LoadTheme(filename)
    f = openfile(filename)
    if typeof(f)
        setting = frln(f)
        while setting
            setting = replace(replace(setting, " ", ""), chr(9), "")
            pair = split(setting, "=")
            if sizeof(pair) = 2
                c = split(pair[1], ",")
                if sizeof(c) >= 3
                    for i = 0 to sizeof(c) - 1  c[i] = int(c[i])
                    select upper(pair[0])
                        case "BACKGROUND"  SetColorRGB(COLOR_BACKGROUND, c[0], c[1], c[2])
                        case "TEXT"  SetColorRGB(COLOR_TEXT, c[0], c[1], c[2])
                        case "PRIMARY_BACKGROUND"  SetColorRGB(COLOR_PRIMARY_BACKGROUND, c[0], c[1], c[2])
                        case "PRIMARY_TEXT"  SetColorRGB(COLOR_PRIMARY_TEXT, c[0], c[1], c[2])
                        case "BORDER"  SetColorRGB(COLOR_BORDER, c[0], c[1], c[2])
                        case "LIGHT_BORDER"  SetColorRGB(COLOR_LIGHT_BORDER, c[0], c[1], c[2])
                        case "MENU_BACKGROUND"  SetColorRGB(COLOR_MENU_BACKGROUND, c[0], c[1], c[2])
                        case "MENU_TEXT"  SetColorRGB(COLOR_MENU_TEXT, c[0], c[1], c[2])
                        case "MENUBAR_BACKGROUND"  SetColorRGB(COLOR_MENUBAR_BACKGROUND, c[0], c[1], c[2])
                        case "MENUBAR_TEXT"  SetColorRGB(COLOR_MENUBAR_TEXT, c[0], c[1], c[2])
                        case "TOOLTIP_BACKGROUND"  SetColorRGB(COLOR_TOOLTIP_BACKGROUND, c[0], c[1], c[2])
                        case "TOOLTIP_TEXT"  SetColorRGB(COLOR_TOOLTIP_TEXT, c[0], c[1], c[2])
                        case "ED_BACKGROUND"  SetColorRGB(COLOR_ED_BACKGROUND, c[0], c[1], c[2])
                        case "ED_TEXT"  SetColorRGB(COLOR_ED_TEXT, c[0], c[1], c[2])
                        case "ED_SELECTION"  SetColorRGB(COLOR_ED_SELECTION, c[0], c[1], c[2])
                        case "ED_LN_BACKGROUND"  SetColorRGB(COLOR_ED_LN_BACKGROUND, c[0], c[1], c[2])
                        case "ED_LN_TEXT"  SetColorRGB(COLOR_ED_LN_TEXT, c[0], c[1], c[2])
                        case "SHADOW"  SetColorRGBA(COLOR_SHADOW, c[0], c[1], c[2], c[3])
                        case "SH_KEYWORD"  SetColorRGB(COLOR_SH_KEYWORD, c[0], c[1], c[2])
                        case "SH_CONSTANT"  SetColorRGB(COLOR_SH_CONSTANT, c[0], c[1], c[2])
                        case "SH_STRING"  SetColorRGB(COLOR_SH_STRING, c[0], c[1], c[2])
                        case "SH_NUMBER"  SetColorRGB(COLOR_SH_NUMBER, c[0], c[1], c[2])
                        case "SH_COMMENT"  SetColorRGB(COLOR_SH_COMMENT, c[0], c[1], c[2])
                        case "SH_FLAG"  SetColorRGB(COLOR_SH_FLAG, c[0], c[1], c[2])
                    endsel
                endif
            endif
            setting = frln(f)            
        wend
        free file f
        return true
    else
        return false
    endif
endfunc

function SaveTheme(filename)
    if not filename  return false
    f = createfile(filename)
    if typeof(f)
        wln file f, "BACKGROUND=" + ToString(vColors[COLOR_BACKGROUND])
        wln file f, "TEXT=" + ToString(vColors[COLOR_TEXT])
        wln file f, "PRIMARY_BACKGROUND=" + ToString(vColors[COLOR_PRIMARY_BACKGROUND])
        wln file f, "PRIMARY_TEXT=" + ToString(vColors[COLOR_PRIMARY_TEXT])
        wln file f, "BORDER=" + ToString(vColors[COLOR_BORDER])
        wln file f, "LIGHT_BORDER=" + ToString(vColors[COLOR_LIGHT_BORDER])
        wln file f, "MENU_BACKGROUND=" + ToString(vColors[COLOR_MENU_BACKGROUND])
        wln file f, "MENU_TEXT=" + ToString(vColors[COLOR_MENU_TEXT])
        wln file f, "MENUBAR_BACKGROUND=" + ToString(vColors[COLOR_MENUBAR_BACKGROUND])
        wln file f, "MENUBAR_TEXT=" + ToString(vColors[COLOR_MENUBAR_TEXT])
        wln file f, "TOOLTIP_BACKGROUND=" + ToString(vColors[COLOR_TOOLTIP_BACKGROUND])
        wln file f, "TOOLTIP_TEXT=" + ToString(vColors[COLOR_TOOLTIP_TEXT])
        wln file f, "ED_BACKGROUND=" + ToString(vColors[COLOR_ED_BACKGROUND])
        wln file f, "ED_TEXT=" + ToString(vColors[COLOR_ED_TEXT])
        wln file f, "ED_SELECTION=" + ToString(vColors[COLOR_ED_SELECTION])
        wln file f, "ED_LN_BACKGROUND=" + ToString(vColors[COLOR_ED_LN_BACKGROUND])
        wln file f, "ED_LN_TEXT=" + ToString(vColors[COLOR_ED_LN_TEXT])
        wln file f, "SHADOW=" + ToString(vColors[COLOR_SHADOW])
        wln file f, "SH_KEYWORD=" + ToString(vColors[COLOR_SH_KEYWORD])
        wln file f, "SH_CONSTANT=" + ToString(vColors[COLOR_SH_CONSTANT])
        wln file f, "SH_STRING=" + ToString(vColors[COLOR_SH_STRING])
        wln file f, "SH_NUMBER=" + ToString(vColors[COLOR_SH_NUMBER])
        wln file f, "SH_COMMENT=" + ToString(vColors[COLOR_SH_COMMENT])
        wln file f, "SH_FLAG=" + ToString(vColors[COLOR_SH_FLAG])
        free file f
        return true
    else
        return false
    endif

    function ToString(c)
        if sizeof(c) = 4  return int(c[0]) + "," + int(c[1]) + "," + int(c[2]) + "," + int(c[3])
        else  return int(c[0]) + "," + int(c[1]) + "," + int(c[2]) + "," + int(c[3])
    endfunc
endfunc

' SetDefaultFont
' --------------
' Set default font, used for labels, buttons et.c.
function SetDefaultFont(name, size)
    create font vDefaultFont, name, size, false, false, false, true
    vLayoutChanged = true
endfunc

' GetDefaultFont
' --------------
function GetDefaultFont()
    return vDefaultFont
endfunc

' SetHeaderFont
' -------------
' Set header font, used for headers.
function SetHeaderFont(name, size)
    create font vHeaderFont, name, size, true, false, false, true
    vLayoutChanged = true
endfunc

' GetHeaderFont
' -------------
function GetHeaderFont()
    return vHeaderFont
endfunc

' SetTextEntryFont
' ----------------
' Set font for TextEntry widgets, must be fixed width.
function SetTextEntryFont(name, size)
    create font vTextEntryFont, name, size, false, false, false, true
    vLayoutChanged = true
endfunc

' GetTextEntryFont
' ----------------
function GetTextEntryFont()
    return vTextEntryFont
endfunc

' SetTextEditorFont
' -----------------
' Set font for TextEditor widgets, must be fixed width.
function SetTextEditorFont(name, size)
    create font vTextEditorFont, name, size, false, false, false, true
    vLayoutChanged = true
endfunc

' GetTextEditorFont
' -----------------
function GetTextEditorFont()
    return vTextEditorFont
endfunc

' ExitMainLoop
' ------------
' Return from main loop.
function ExitMainLoop()
    vRunning = false
endfunc

function ClearCommands()
    vCommandKeys = []
endfunc

function AddCommand(k, cb)
    vCommandKeys[sizeof(vCommandKeys)] = [k: k, cb: cb]
endfunc

function ClearFunctions()
    vFunctionKeys = []
endfunc

function AddFunction(k, cb)
    vFunctionKeys[sizeof(vFunctionKeys)] = [k: k, cb: cb]
endfunc

function SendWindowMessage(title, msg)
    system("n7:winmsg " + chr(34) + title + chr(34) + " " + chr(34) + msg + chr(34))
endfunc

function SetWindowMessageAction(cb)
    vWinMsgAction = cb    
endfunc

function ShowWindow()
    system("n7:winshow")
endfunc

function SetFocus(wdg)
    if vKeyboardWdg and typeof(vKeyboardWdg.LostFocus)  vKeyboardWdg.LostFocus()
    vKeyboardWdg = wdg
    if vKeyboardWdg and typeof(vKeyboardWdg.GotFocus)  vKeyboardWdg.GotFocus()
endfunc

' MarkAllDirty
' ------------
' Mark all widgets as dirty for a full redraw.
function MarkAllDirty()
    if vRoot vRoot.MarkDirty()
    if sizeof(vPopups)
        for i = 0 to sizeof(vPopups) - 1  vPopups[i].MarkDirty()
    endif
endfunc

' ClearMouse
' ----------
function ClearMouse()
    if vMouseWdg
        if vMouseWdg.MouseLeave  vMouseWdg.MouseLeave()
        if vMouseWdg.MouseUp  vMouseWdg.MouseUp(-1, -1)
        vMouseWdg = unset
    endif
    if vMouseOverWdg and vMouseOverWdg.MouseLeave  vMouseOverWdg.MouseLeave()
    ClearTooltip()
    vMouseOverWdg = unset
    vMouseX = -1
    vMouseY = -1
    ' Mark clicks as handled, or there'll be annoying click-throughs when popups
    ' are closed.
    tmp = mousebutton(0, true)
    tmp = mousebutton(1, true)
endfunc

' ClearTooltip
' ------------
function ClearTooltip()
    if vTooltip
        vTooltip = unset
        vMouseOverWdgTime = clock()
        MarkAllDirty()
    endif
endfunc

' AddTooltip
' ----------
function AddTooltip(wdg)
    ClearTooltip()
    vVolatileTooltip = false
    if typeof(wdg.tooltip) = TYPE_FUNCTION
        if wdg.volatileTooltip
            vTooltip = wdg.tooltip(wdg, vMouseX - wdg.x, vMouseY - wdg.y)
            vVolatileTooltip = true
        else
            vTooltip = wdg.tooltip(wdg)
        endif
    else
        vTooltip = wdg.tooltip
    endif
    if vTooltip
        vTooltipW = fwidth(vDefaultFont, vTooltip) + 6
        vTooltipH = fheight(vDefaultFont) + 6
        vTooltipX = max(vMouseX - vTooltipW/2, 0)
        if vTooltipX + vTooltipW >= width(primary) vTooltipX = width(primary) - vTooltipW - 1
        vTooltipY = max(vMouseY - vTooltipH - 6, 0)
        vAnyDirty = true
    endif
endfunc

' ShowPopup
' ---------
function ShowPopup(popup, mode, close)
    ' Put widget with keyboard focus on stack.
    vKeyboardWdgStack[sizeof(vKeyboardWdgStack)] = vKeyboardWdg
    vKeyboardWdg = unset

    ' Add popup.
    vPopups[sizeof(vPopups)] = popup
    popup.Close = close
    popup.mode = mode
    ClearMouse()
    ClearTooltip()
    popup.MarkDirty()
endfunc

' ClosePopup
' ----------
function ClosePopup(msg)
    assert sizeof(vPopups), "There's no open popup"
    
    ' Remove popup and call its Close function.
    popup = vPopups[sizeof(vPopups) - 1]
    free key vPopups, sizeof(vPopups) - 1
    ClearMouse()
    ClearTooltip()
    ' Pop widget with keyboard focus from stack.
    vKeyboardWdg = Last(vKeyboardWdgStack)
    free key vKeyboardWdgStack, sizeof(vKeyboardWdgStack) - 1
    ' Callback.
    if popup.Close  popup.Close(popup, msg)

    MarkAllDirty()
endfunc

' UpdateMouse
' -----------
function UpdateMouse()
    prevMouseX = vMouseX
    prevMouseY = vMouseY
    vMouseX = mousex()
    vMouseY = mousey()
    prevLeftMB = vLeftMB
    prevRightMB = vRightMB
    vLeftMB = mousebutton(0)
    vRightMB = mousebutton(1)

    friendSource = unset
    if sizeof(vPopups)
        source = vPopups[sizeof(vPopups) - 1]
        if key(source, "friend")
            friendSource = source.friend
        endif
    else
        source = vRoot
    endif

    if vMouseWdg
        ' Still send enter/leave
        if vMouseX <> prevMouseX or vMouseY <> prevMouseY
            if vMouseX >= vMouseWdg.x and vMouseX < vMouseWdg.x + vMouseWdg.w and
                    vMouseY >= vMouseWdg.y and vMouseY < vMouseWdg.y + vMouseWdg.h
                if not vMouseOverWdg = vMouseWdg
                    vMouseOverWdg = vMouseWdg
                    if vMouseWdg.MouseEnter  vMouseWdg.MouseEnter()
                endif
            else
                if vMouseOverWdg = vMouseWdg
                    vMouseOverWdg = unset
                    if vMouseWdg.MouseLeave  vMouseWdg.MouseLeave()
                endif
            endif
            if vMouseWdg.MouseDrag  vMouseWdg.MouseDrag(vMouseX - vMouseWdg.x,
                    vMouseY - vMouseWdg.y)
        endif
        if not vLeftMB
            if vMouseWdg.MouseUp  vMouseWdg.MouseUp(vMouseX - vMouseWdg.x, vMouseY - vMouseWdg.y)
            vMouseWdg = 0
        else
            if vMouseWdg.MousePressed vMouseWdg.MousePressed(vMouseX - vMouseWdg.x,
                    vMouseY - vMouseWdg.y)
        endif
    else
        if vMouseX <> prevMouseX or vMouseY <> prevMouseY
            if vTooltip and vVolatileTooltip  ClearTooltip()
            wdg = MouseMotionRec(source)
            if wdg = unset and friendSource  wdg = MouseMotionRec(friendSource)
            if not vMouseOverWdg = wdg
                ClearTooltip()
                if vMouseOverWdg and vMouseOverWdg.MouseLeave  vMouseOverWdg.MouseLeave()
                vMouseOverWdg = wdg
                vMouseOverWdgTime = clock()
                if vMouseOverWdg and vMouseOverWdg.MouseEnter  vMouseOverWdg.MouseEnter()
            endif
            if vMouseOverWdg
            if vMouseOverWdg.volatileTooltip  vMouseOverWdgTime = clock()
                if vMouseOverWdg.MouseMove  vMouseOverWdg.MouseMove(
                        vMouseX - vMouseOverWdg.x, vMouseY - vMouseOverWdg.y)
            endif
        endif
        if vMouseOverWdg
            if vTooltip = unset and vMouseOverWdg.tooltip and
                    clock() - vMouseOverWdgTime > vTooltipDelay
                AddTooltip(vMouseOverWdg)
            endif
            if mousebutton(2) and typeof(vMouseOverWdg.MouseWheel)
                vMouseOverWdg.MouseWheel(mousebutton(2, true))
            endif
        endif

        if vLeftMB
            ClearTooltip()
            ' 20250824.
            if vKeyboardWdg and vKeyboardWdg <> vMouseOverWdg
                if typeof(vKeyboardWdg.LostFocus)  vKeyboardWdg.LostFocus()
                vKeyboardWdg = unset
            endif
            if vMouseOverWdg
                if vMouseOverWdg.wantsKeyboard and vMouseOverWdg <> vKeyboardWdg
                    ' 20250824.
                    'if vKeyboardWdg and typeof(vKeyboardWdg.LostFocus)  vKeyboardWdg.LostFocus()
                    vKeyboardWdg = vMouseOverWdg
                    if typeof(vKeyboardWdg.GotFocus)  vKeyboardWdg.GotFocus()
                endif
                vMouseWdg = vMouseOverWdg
                if vMouseWdg.MouseDown
                    vMouseWdg.MouseDown(vMouseX - vMouseWdg.x, vMouseY - vMouseWdg.y)
                endif
            else
                if sizeof(vPopups)
                    if vPopups[sizeof(vPopups) - 1].mode = POPUP_CLOSE
                        ClosePopup(unset)
                    endif
                endif
            endif
        endif
    endif

    function MouseMotionRec(wdg)
        if wdg.hidden = false and vMouseX >= wdg.x and vMouseX < wdg.x + wdg.w and
                vMouseY >= wdg.y and vMouseY < wdg.y + wdg.h
            if wdg.children and sizeof(wdg.children)
                for i = 0 to sizeof(wdg.children) - 1
                    c = MouseMotionRec(wdg.children[i])
                    if c  return c
                next
            endif
            return wdg
        else
            return unset
        endif
    endfunc
endfunc

function UpdateKeyboard()
    ctrl = keydown(KEY_CONTROL)

    ' Commands.
    if ctrl
        if not ((vKeyboardWdg and typeof(vKeyboardWdg.CommandKeyDown) and
                vKeyboardWdg.CommandKeyDown()) or sizeof(vPopups))
            ' look for programs registered commands
            if sizeof(vCommandKeys) > 0
                for i = 0 to sizeof(vCommandKeys) - 1
                    if keydown(vCommandKeys[i].k, true)  vCommandKeys[i].cb()
                next
            endif
        endif
    ' Regular keyboard input.
    else
        if vKeyboardWdg and typeof(vKeyboardWdg.KeyDown)
            c = inkey()
            while c
                vKeyboardWdg.KeyDown(c)
                c = inkey()
            wend
        endif
        ' Keys with registered callbacks.
        if sizeof(vFunctionKeys) > 0 and not sizeof(vPopups)
            for i = 0 to sizeof(vFunctionKeys) - 1
                if keydown(vFunctionKeys[i].k, true)  vFunctionKeys[i].cb()
            next
        endif
    endif

    if vKeyboardWdg and typeof(vKeyboardWdg.Update) vKeyboardWdg.Update()
endfunc

' Widget
' ------
function Widget()
    return [
            ' Actual position.
            x: 0, y: 0,
            ' Actual width and height.
            w: 0, h: 0,
            ' Width and height settings.
            ww: SIZE_AUTO, wh: SIZE_AUTO,
            ' Dirty flag.
            dirty: true,
            ' Parent.
            parent: unset,
            ' Children.
            children: unset,
            ' Alignment of children.
            halign: ALIGN_LEFT,
            valign: ALIGN_TOP,
            ' Colors.
            background: unset,
            foreground: unset,
            ' Extra spaceing.
            padding: 0,
            innerPadding: 0,
            border: 0,
            ' Flags.
            hidden: false,
            wantsKeyboard: false,
            ' Tooltip.
            tooltip: unset,
            volatileTooltip: false,
            ' Mouse callbacks.
            MouseEnter: unset,
            MouseLeave: unset,
            MouseDown: unset,
            MouseUp: unset,
            MouseMove: unset,
            MouseDrag: unset,
            MousePressed: unset,
            MouseWheel: unset,
            ' Keyboard callbacks.
            GotFocus: unset,
            LostFocus: unset,
            KeyDown: unset,
            Update: unset,
            CommandKeyDown: unset,

            ' Cleanup function.
            Removed: function()
                WidgetRemoved(this)
            endfunc,

            MarkDirty: function()
                vAnyDirty = true
                this.dirty = true
                if this.children and sizeof(this.children)
                    for i = 0 to sizeof(this.children) - 1  this.children[i].MarkDirty()
                endif
            endfunc,

            LayoutChanged: function()
                vLayoutChanged = true
            endfunc,

            GetChildren: function()
                return this.children
            endfunc,

            GetParent: function()
                return this.parent
            endfunc,

            IsHidden: function()
                return this.hidden
            endfunc,

            SetHidden: function(value)
                if value <> this.hidden
                    this.hidden = value
                    vLayoutChanged = true
                endif
            endfunc,

            GetTooltip: function()
                return this.tooltip
            endfunc,

            SetTooltip: function(value)
                this.tooltip = value
                this.volatileTooltip = false
            endfunc,

            SetVolatileTooltip: function(value)
                this.tooltip = value
                this.volatileTooltip = true
            endfunc,

            ' Not all widget use halign/valign, but whatever.
            GetValign: function()
                return this.valign
            endfunc,

            SetValign: function(value)
                assert value = ALIGN_TOP or value = ALIGN_BOTTOM or value = ALIGN_CENTER
                this.valign = value
                vLayoutChanged = true
            endfunc,

            GetHalign: function()
                return this.halign
            endfunc,

            SetHalign: function(value)
                assert value = ALIGN_LEFT or value = ALIGN_RIGHT or value = ALIGN_CENTER
                this.halign = value
                vLayoutChanged = true
            endfunc,
            
            SetBackground: function(c)
                this.background = c
                this.MarkDirty()
            endfunc,

            SetForeground: function(c)
                this.foreground = c
                this.MarkDirty()
            endfunc
        ]
endfunc

' WidgetRemoved
' -------------
' MUST be called from every widgets Removed function!
function WidgetRemoved(wdg)
    if vMouseOverWdg = wdg  vMouseOverWdg = unset
    if vMouseWdg = wdg  vMouseWdg = unset
    if vKeyboardWdg = wdg  vKeyboardWdg = unset
endfunc

' Getters and setters for common widget properties
' ------------------------------------------------

function GetPadding()
    return this.padding
endfunc

function SetPadding(value)
    if value <> this.padding
        this.padding = max(value, 0)
        vLayoutChanged = true
    endif
endfunc

function GetInnerPadding()
    return this.innerPadding
endfunc

function SetInnerPadding(value)
    if value <> this.innerPadding
        this.innerPadding = max(value, 0)
        vLayoutChanged = true
    endif
endfunc

function GetBorder()
    return this.border
endfunc

function SetBorder(value)
    if value <> this.border
        this.border = max(value, 0)
        vLayoutChanged = true
    endif
endfunc

function SetBorderColor(value)
    if value <> this.borderColor
        this.borderColor = value
        this.MarkDirty()
    endif
endfunc

function IsBorderInside()
    return this.borderInside
endfunc

function SetBorderInside(value)
    this.borderInside = value
    this.MarkDirty()
endfunc

function GetSpacing()
    return this.spacing
endfunc

function SetSpacing(value)
    if value <> this.spacing
        this.spacing = max(value, 0)
        vLayoutChanged = true
    endif
endfunc

function BoxRemove(wdg)
    found = false
    foreach child in this.children
        if wdg = child
            found = true
            break
        endif
    next
    if found
        if wdg.Removed  wdg.Removed()
        free val this.children, wdg
        vLayoutChanged = true
    endif
endfunc

function BoxRemoved()
    WidgetRemoved(this)
    foreach child in this.children
        if child.Removed  child.Removed()
    next
    clear this.children
endfunc

' Box
' ---
' A container for exactly one child.
function Box(w, h)
    wdg = Widget()
    wdg.children = []
    wdg.ww = w
    wdg.wh = h
    wdg.background = vColors[COLOR_BACKGROUND]
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.padding = 0
    wdg.border = 0
    wdg.borderInside = false
    wdg.shadow = 0

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder
    wdg.SetBorderColor = SetBorderColor
    wdg.IsBorderInside = IsBorderInside
    wdg.SetBorderInside = SetBorderInside

    wdg.Add = function(wdg)
        assert sizeof(this.children) < 1, "A Box can only have one child"
        this.children[0] = wdg
        wdg.parent = this
        vLayoutChanged = true
    endfunc

    wdg.Resize = function(w, h)
        assert sizeof(this.children) = 1, "A Box must contain one child"

        if this.hidden  return

        pad = this.padding + this.border

        this.x = this.x + pad
        this.y = this.y + pad

        if this.ww = SIZE_EXPAND
            this.w = w - pad*2
        elseif this.ww = SIZE_AUTO
            this.w = this.children[0].MinWidth()
        else
            this.w = this.ww
        endif

        if this.wh = SIZE_EXPAND
            this.h = h - pad*2
        elseif this.wh = SIZE_AUTO
            this.h = this.children[0].MinHeight()
        else 
            this.h = this.wh
        endif

        if this.halign = ALIGN_LEFT or this.children[0].ww = SIZE_EXPAND  this.children[0].x = this.x
        elseif this.halign = ALIGN_CENTER  this.children[0].x = this.x + (this.w - this.children[0].MinWidth())/2
        else  this.children[0].x = this.x + this.w - this.children[0].MinWidth()
        
        if this.valign = ALIGN_TOP or this.children[0].wh = SIZE_EXPAND  this.children[0].y = this.y
        elseif this.valign = ALIGN_CENTER  this.children[0].y = this.y + (this.h - this.children[0].MinHeight())/2
        else  this.children[0].y = this.y + this.h - this.children[0].MinHeight()

        this.children[0].Resize(this.w, this.h)

        this.x = this.x - pad
        this.y = this.y - pad
        this.w = this.w + pad*2
        this.h = this.h + pad*2
    endfunc

    wdg.MinWidth = function()
        'if this.hidden return 
        if this.ww > 0  return this.ww + (this.padding + this.border)*2
        else  return this.children[0].MinWidth() + (this.padding + this.border)*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + (this.padding + this.border)*2
        else return this.children[0].MinHeight() + (this.padding + this.border)*2
    endfunc

    wdg.Draw = function(bg)
        if this.hidden  return
        if this.background  bg = this.background
        child = this.children[0]

        if this.dirty
            if this.background
                if vColors[COLOR_SHADOW] and this.shadow > 0
                    set color vColors[COLOR_SHADOW]
                    draw rect this.x + this.shadow, this.y + this.shadow, this.w, this.h, true
                endif
                set color this.background
                draw rect this.x, this.y, this.w, this.h, true
         endif
            if this.border > 0 and this.borderColor
                set color this.borderColor
                if this.borderInside
                    for i = 0 to this.border - 1
                        draw rect this.x + this.padding + i, this.y + this.padding + i,
                                this.w - (this.padding + i)*2, this.h - (this.padding + i)*2, false
                    next
                else
                    for i = 0 to this.border - 1
                        draw rect this.x + i, this.y + i, this.w - i*2, this.h - i*2, false
                    next
                endif
            endif
            this.dirty = false
        endif
        if child.children
            child.Draw(bg)
        elseif child.dirty
            if not child.background
                set color bg
                draw rect child.x, child.y, child.w, child.h
            endif
            child.Draw()
            child.dirty = false
        endif
    endfunc

    return wdg
endfunc

' VBox
' ----
' A container that arranges its children vertically.
function VBox(w, h)
    wdg = Widget()
    wdg.children = []
    wdg.ww = w
    wdg.wh = h
    wdg.padding = 0
    wdg.spacing = 0
    wdg.border = 0
    wdg.borderInside = false
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.shadow = 0

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder
    wdg.SetBorderColor = SetBorderColor
    wdg.IsBorderInside = IsBorderInside
    wdg.SetBorderInside = SetBorderInside
    wdg.GetSpacing = GetSpacing
    wdg.SetSpacing = SetSpacing
    wdg.Remove = BoxRemove
    wdg.Removed = BoxRemoved

    wdg.Add = function(wdg)
        this.children[sizeof(this.children)] = wdg
        wdg.parent = this
        vLayoutChanged = true
    endfunc

    wdg.Resize = function(w, h)
        if this.hidden  return

        pad = this.padding + this.border
        this.x = this.x + pad
        this.y = this.y + pad

        if this.ww = SIZE_EXPAND
            this.w = w - pad*2
        elseif this.ww = SIZE_AUTO
            this.w = 0
            foreach child in this.children
                if not child.hidden  this.w = max(this.w, child.MinWidth())
            next
        else
            this.w = this.ww
        endif

        'spacing = this.spacing*max(sizeof(this.children) - 1, 0)
        count = 0
        foreach child in this.children  if not child.hidden  count = count + 1
        spacing = this.spacing*max(count - 1, 0)          

        if this.wh = SIZE_EXPAND
            this.h = h - pad*2
        elseif this.wh = SIZE_AUTO
            this.h = spacing
            foreach child in this.children
                if not child.hidden  this.h = this.h + child.MinHeight()
            next
        else
            this.h = this.wh
        endif

        minh = spacing
        expands = 0
        foreach child in this.children
            if not child.hidden
                minh = minh + child.MinHeight()
                if child.wh = SIZE_EXPAND  expands = expands + 1
            endif
        next
        extra = max(this.h - minh, 0)
        if this.valign = ALIGN_TOP or expands > 0
            y = this.y
        elseif this.valign = ALIGN_CENTER
            y = this.y + int(extra/2)
        else
            y = this.y + extra
        endif

        if expands > 0  extra = int(extra/expands)
        if sizeof(this.children) > 0
            for i = 0 to sizeof(this.children) - 1
                c = this.children[i]
                if not c.hidden            
                    if c.ww = SIZE_EXPAND  w = this.w
                    else w = c.MinWidth()
        
                    if this.halign = ALIGN_LEFT or c.ww = SIZE_EXPAND  c.x = this.x
                    else if this.halign = ALIGN_CENTER  c.x = this.x + int((this.w - w)/2)
                    else  c.x = this.x + this.w - w
        
                    c.y = y
                    if c.wh = SIZE_EXPAND c.Resize(this.w, c.MinHeight() + extra)
                    else c.Resize(this.w, c.MinHeight())
                    y = y + c.h + this.spacing
                endif
            next
        endif

        this.x = this.x - pad
        this.y = this.y - pad
        this.w = this.w + pad*2
        this.h = this.h + pad*2
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0
            return this.ww + (this.padding + this.border)*2
        else
            minw = 0
            foreach child in this.children  if not child.hidden minw = max(minw, child.MinWidth())
            return minw + (this.padding + this.border)*2
        endif
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0
            return this.wh + (this.padding + this.border)*2
        else
            count = 0
            foreach child in this.children  if not child.hidden  count = count + 1
            minh = this.spacing*max(count - 1, 0) + (this.padding + this.border)*2
            foreach child in this.children  if not child.hidden  minh = minh + child.MinHeight()
            return minh
        endif
    endfunc

    wdg.Draw = function(bg)
        if this.hidden  return

        if this.background bg = this.background
        if this.dirty
            if this.background
                if vColors[COLOR_SHADOW] and this.shadow > 0
                    set color vColors[COLOR_SHADOW]
                    draw rect this.x + this.shadow, this.y + this.shadow, this.w, this.h, true
                endif
                set color this.background
                draw rect this.x, this.y, this.w, this.h, true            
            endif
            if this.border > 0 and this.borderColor
                set color this.borderColor
                if this.borderInside
                    for i = 0 to this.border - 1
                        draw rect this.x + this.padding + i, this.y + this.padding + i,
                                this.w - (this.padding + i)*2, this.h - (this.padding + i)*2, false
                    next
                else
                    for i = 0 to this.border - 1
                        draw rect this.x + i, this.y + i, this.w - i*2, this.h - i*2, false
                    next
                endif
            endif
            this.dirty = false
        endif
        if sizeof(this.children)
            for i = 0 to sizeof(this.children) - 1
                child = this.children[i]
                if not child.hidden
                    if typeof(child.children)
                        child.Draw(bg)
                    elseif child.dirty
                        if not child.background
                            set color bg
                            draw rect child.x, child.y, child.w, child.h, true
                        endif                       
                        child.Draw()
                        child.dirty = false
                    endif
                endif
            next
        endif
    endfunc 

    return wdg
endfunc

' HBox
' ----
' A container that arranges its children horizontally.
function HBox(w, h)
    wdg = Widget()
    wdg.children = []
    wdg.ww = w
    wdg.wh = h
    wdg.padding = 0
    wdg.spacing = 0
    wdg.border = 0
    wdg.borderInside = false
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.shadow = 0

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder
    wdg.SetBorderColor = SetBorderColor
    wdg.IsBorderInside = IsBorderInside
    wdg.SetBorderInside = SetBorderInside
    wdg.GetSpacing = GetSpacing
    wdg.SetSpacing = SetSpacing
    wdg.Remove = BoxRemove
    wdg.Removed = BoxRemoved

    wdg.Add = function(wdg)
        this.children[sizeof(this.children)] = wdg
        wdg.parent = this
        vLayoutChanged = true
    endfunc
    
    wdg.AddFirst = function(wdg)
        insert this.children, 0,  wdg
        wdg.parent = this
        vLayoutChanged = true
    endfunc

    wdg.Resize = function(w, h)
        pad = this.padding + this.border
        this.x = this.x + pad
        this.y = this.y + pad

        if this.wh = SIZE_EXPAND
            this.h = h - pad*2
        elseif this.wh = SIZE_AUTO
            this.h = 0
            foreach child in this.children
                if not child.hidden  this.h = max(this.h, child.MinHeight())
            next
        else
            this.h = this.wh            
        endif

        count = 0
        foreach child in this.children  if not child.hidden  count = count + 1
        spacing = this.spacing*max(count - 1, 0)
        'spacing = this.spacing*max(sizeof(this.children) - 1, 0)
        
        if this.ww = SIZE_EXPAND
            this.w = w - pad*2
        elseif this.ww = SIZE_AUTO
            this.w = spacing
            foreach child in this.children
                if not child.hidden  this.w = this.w + child.MinWidth()
            next
        else
            this.w = this.ww
        endif

        minw = spacing
        expands = 0
        foreach child in this.children
            if not child.hidden
                minw = minw + child.MinWidth()
                if child.ww = SIZE_EXPAND  expands = expands + 1
            endif
        next
        extra = max(this.w - minw, 0)
        if this.halign = ALIGN_LEFT or expands > 0
            x = this.x
        elseif this.halign = ALIGN_CENTER
            x = this.x + int(extra/2)
        else
            x = this.x + extra
        endif

        if expands > 0  extra = int(extra/expands)
        if sizeof(this.children)
            for i = 0 to sizeof(this.children) - 1
                c = this.children[i]
                if not c.hidden
                    if c.wh = SIZE_EXPAND  h = this.h
                    else h = c.MinHeight()
    
                    if this.valign = ALIGN_TOP or c.wh = SIZE_EXPAND  c.y = this.y
                    else if this.valign = ALIGN_CENTER  c.y = this.y + int((this.h - h)/2)
                    else  c.y = this.y + this.h - h
        
                    c.x = x
                    if c.ww = SIZE_EXPAND c.Resize(c.MinWidth() + extra, this.h)
                    else c.Resize(c.MinWidth(), this.h)
                    x = x + c.w + this.spacing
                endif
            next
        endif

        this.x = this.x - pad
        this.y = this.y - pad
        this.w = this.w + pad*2
        this.h = this.h + pad*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0
            return this.wh + (this.padding + this.border)*2
        else
            minh = 0
            foreach child in this.children  if not child.hidden  minh = max(minh, child.MinHeight())
            return minh + (this.padding + this.border)*2
        endif
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0
            return this.ww + (this.padding + this.border)*2
        else
            count = 0
            foreach child in this.children  if not child.hidden  count = count + 1
            minw = this.spacing*max(count - 1, 0) + (this.padding + this.border)*2
            'minw = this.spacing*max(sizeof(this.children) - 1, 0) + (this.padding + this.border)*2
            foreach child in this.children  if not child.hidden  minw = minw + child.MinWidth()
            return minw
        endif
    endfunc

    wdg.Draw = function(bg)
        if this.hidden  return

        if this.background  bg = this.background
        if this.dirty
            if this.background
                if vColors[COLOR_SHADOW] and this.shadow > 0
                    set color vColors[COLOR_SHADOW]
                    draw rect this.x + this.shadow, this.y + this.shadow, this.w, this.h, true
                endif
                set color this.background
                draw rect this.x, this.y, this.w, this.h, true
            endif
            if this.border > 0 and this.borderColor
                set color this.borderColor
                if this.borderInside
                    for i = 0 to this.border - 1
                        draw rect this.x + this.padding + i, this.y + this.padding + i,
                                this.w - (this.padding + i)*2, this.h - (this.padding + i)*2, false
                    next
                else
                    for i = 0 to this.border - 1
                        draw rect this.x + i, this.y + i, this.w - i*2, this.h - i*2, false
                    next
                endif
            endif
            this.dirty = false
        endif
        if sizeof(this.children)
            for i = 0 to sizeof(this.children) - 1
                child = this.children[i]
                if not child.hidden
                    if typeof(child.children)
                        child.Draw(bg)
                    elseif child.dirty
                        if not child.background
                            set color bg
                            draw rect child.x, child.y, child.w, child.h, true
                        endif                       
                        child.Draw()
                        child.dirty = false
                    endif
                endif
            next
        endif
    endfunc 

    return wdg
endfunc

' TabBox
' ------
' A VBox where the first child is a HBox with TextButtons.
function TabBox(w, h)
    wdg = VBox(w, h)
    wdg.spacing = 0
    wdg.items = HBox(w, SIZE_AUTO)
    wdg.items.spacing = vTabItemSpacing
    wdg.items.padding = 0
    wdg.Add(wdg.items)
    wdg.current = unset
    wdg.Action = unset
    wdg.CloseRequestAction = unset
    wdg.CloseAction = unset
    
    wdg.Add = function(name, wdg, closeButton)
        item = TabItem(name, wdg, closeButton)
        item.tabBox = this
        item.parent = this
        this.items.Add(item)
        return item
    endfunc

    ' SetAction
    ' ---------
    ' Called when selected tab changes.
    wdg.SetAction = function(action)
        this.Action = action
    endfunc

    ' SetCloseRequestAction
    ' ---------------------
    ' Called when the button of an item has been clicked.
    wdg.SetCloseRequestAction = function(action)
        this.CloseRequestAction = action
    endfunc

    ' SetCloseAction
    ' --------------
    ' Called when a tab has actually been removed.
    wdg.SetCloseAction = function(action)
        this.CloseAction = action
    endfunc

    wdg.Count = function()
        return sizeof(this.items.children)
    endfunc

    wdg.GetLabel = function(wdg)
        tabItem = FindMatchingField(this.items.children, "content", wdg)
        if tabItem  return tabItem.label
        else  return unset
    endfunc

    wdg.GetItem = function(index)
        if index >= 0 and index < sizeof(this.items.children)
            return this.items.children[index].content
        else
            return unset
        endif
    endfunc

    wdg.GetCurrentItem = function()
        return this.current
    endfunc

    wdg.GetCurrentItemIndex = function()
        return this.GetIndexOf(this.current)
    endfunc

    wdg.GetIndexOf = function(wdg)
        if sizeof(this.items.children)
            for i = 0 to sizeof(this.items.children) - 1
                if this.items.children[i].content = wdg  return i
            next
        endif
        return -1
    endfunc
    
    ' GetTabItem
    ' ----------
    ' Get the underlying tab item that contains wdg.
    wdg.GetTabItem = function(wdg)
        if (sizeof(this.items.children))
            for i = 0 to sizeof(this.items.children) - 1
                if this.items.children[i].content = wdg  return this.items.children[i]
            next
        endif
        return unset
    endfunc

    ' SelectItem
    ' ----------
    wdg.SelectItem = function(wdg)
        if this.current = wdg  return
        tabItem = FindMatchingField(this.items.children, "content", wdg)
        if tabItem
            if this.current
                prev = FindMatchingField(this.items.children, "content", this.current)
                if prev  prev.Unselect()
            endif
            tabItem.Select()
            this.current = wdg
            this.children[1] = wdg
            vLayoutChanged = true
            if this.Action  this.Action(wdg)
        endif
    endfunc

    wdg.SelectIndex = function(index)
        if index >= 0 and index < sizeof(this.items.children)
            if this.current
                prev = FindMatchingField(this.items.children, "content", this.current)
                if prev  prev.Unselect()
            endif
            this.current = this.items.children[index].content
            this.children[1] = this.current
            tabItem = FindMatchingField(this.items.children, "content", this.current)
            tabItem.Select()            
            vLayoutChanged = true
            if this.Action  this.Action(this.current)
        endif
    endfunc
    
    ' RequestClose
    ' ------------
    ' Internal call from an item's close button
    wdg.RequestClose_ = function(tabItem)
        if not this.CloseRequestAction or this.CloseRequestAction(tabItem.content)
            this.Close(tabItem.content)
        endif
    endfunc

    wdg.Close = function(wdg)
        tabItem = FindMatchingField(this.items.children, "content", wdg) 
        if tabItem
            index = this.GetIndexOf(wdg)
            this.items.Remove(tabItem)
            if sizeof(this.items.children) > 0
                if this.current = wdg
                    if index = 0
                        this.SelectIndex(index)
                    else
                        this.SelectIndex(index - 1)
                    endif
                endif
            else
                this.Remove(tabItem.content)
                this.current = unset
            endif
            if this.CloseAction  this.CloseAction(wdg)
        endif
    endfunc

    wdg.CloseAll = function(doAction)
        if sizeof(this.items.children)
            closed = []
            while sizeof(this.items.children)
                closed[sizeof(closed)] = this.items.children[0].content
                this.items.Remove(this.items.children[0])
            wend
            if this.current
                this.Remove(this.current)
                this.current = unset
            endif
            if doAction and this.CloseAction
                for i = 0 to sizeof(closed) - 1  this.CloseAction(closed[i])
            endif
        endif
    endfunc

    return wdg
endfunc

' TabItem
' -------
function TabItem(txt, content, closeButton)
    wdg = HBox(SIZE_AUTO, SIZE_AUTO)
    wdg.valign = ALIGN_CENTER
    wdg.padding = 2
    wdg.spacing = 4
    wdg.dividerColor = GetColor(COLOR_LIGHT_BORDER)
    wdg.selectedColor = GetColor(COLOR_PRIMARY_BACKGROUND)
    wdg.icon = unset
    wdg.label = Label(txt, SIZE_AUTO, SIZE_AUTO)
    wdg.label.tabItem = wdg
    wdg.label.MouseDown = function(x, y)
        this.tabItem.tabBox.SelectItem(this.tabItem.content)
    endfunc
    wdg.Add(wdg.label)
    if closeButton
        wdg.closeButton = ImageButton(GetImage(IMAGE_CLOSE_SMALL), function(wdg)
                wdg.tabItem.tabBox.RequestClose_(wdg.tabItem)
            endfunc)
        wdg.closeButton.SetForeground(GetColor(COLOR_PRIMARY_BACKGROUND))
        wdg.closeButton.tabItem = wdg
        wdg.Add(wdg.closeButton)
    else
        wdg.closeButton = unset
    endif
    'wdg.Add(VDivider(1, 0))
    wdg.content = content
    wdg.tabBox = unset
    wdg.selected = false

    wdg.Select = function()
        this.selected = true
        this.MarkDirty()
    endfunc

    wdg.Unselect = function()
        this.selected = false
        this.MarkDirty()
    endfunc

    wdg.Draw_ = wdg.Draw
 
    wdg.Draw = function(bg)
        if this.hidden  return
        wasDirty = this.dirty
        this.Draw_(bg)
        if wasDirty
            if this.selected
                set color this.selectedColor
                draw rect this.label.x, this.y + this.h - 2, this.label.w, 2, true
            endif
            hs = vTabItemSpacing/2
            set color this.dividerColor
            draw rect this.x + this.w + hs, this.y + 2, 1, this.h - 4, true
        endif
    endfunc

    wdg.SetIcon = function(img, c)
        if this.icon
            this.Remove(this.icon)
            this.icon = unset
        endif
        if typeof(img)
            this.icon = Image(img)
            this.AddFirst(this.icon)
            if typeof(c)
                this.icon.SetForeground(c)
            endif
        endif
    endfunc

    return wdg
endfunc


function AtomResize(w, h)
    if this.ww = SIZE_EXPAND  this.w = w
    elseif this.ww = SIZE_AUTO  this.w = min(this.MinWidth(), w)
    else  this.w = min(this.ww + (this.padding + this.border + this.innerPadding)*2, w)

    if this.wh = SIZE_EXPAND this.h = h
    elseif this.wh = SIZE_AUTO  this.h = min(this.MinHeight(), h)
    else  this.h = min(this.wh + (this.padding + this.border + this.innerPadding)*2, h)
endfunc

' Filler
' ------
function Filler(w, h)
    wdg = Widget()
    wdg.ww = w
    wdg.wh = h

    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        return max(this.ww, 0)
    endfunc

    wdg.MinHeight = function()
        return max(this.wh, 0)
    endfunc

    wdg.Draw = function()
    endfunc

    return wdg
endfunc


' Label
' -----
' Single or multiline label, text is split at eol characters (chr(10)).
function Label(txt, w, h)
    wdg = Widget()
    wdg.txt = txt
    if instr(wdg.txt, chr(10)) >= 0  wdg.lines = split(txt, chr(10))
    else  wdg.lines = unset
    wdg.ww = w
    wdg.wh = h
    wdg.fnt = vDefaultFont
    wdg.foreground = vColors[COLOR_TEXT]
    wdg.halign = ALIGN_LEFT
    wdg.valign = ALIGN_CENTER
    wdg.padding = vLabelPadding
    wdg.Resize = AtomResize

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding

    wdg.MinWidth = function()
        if this.ww > 0
            return this.ww + this.padding*2
        else
            if this.lines
                maxW = 0
                foreach ln in this.lines  maxW = max(maxW, fwidth(this.fnt, ln))
                return maxW + this.padding*2
            else
                return fwidth(this.fnt, this.txt) + this.padding*2
            endif
        endif
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0
            return this.wh + this.padding*2
        else
            if this.lines
                return fheight(this.fnt)*sizeof(this.lines) + this.padding*2
            else
                return fheight(this.fnt) + this.padding*2
            endif
        endif
    endfunc

    wdg.SetText = function(txt)
        if txt = this.txt  return

        this.txt = txt
        if instr(this.txt, chr(10)) >= 0  this.lines = split(txt, chr(10))
        else  this.lines = unset
        'vLayoutChanged = true
        
        this.MarkDirty()

        vLayoutChanged = vLayoutChanged or
                this.ww = SIZE_EXPAND and this.w < this.MinWidth() or
                this.ww = SIZE_AUTO and this.w <> this.MinWidth() or
                this.wh = SIZE_EXPAND and this.h < this.MinHeight() or
                this.wh = SIZE_AUTO and this.h <> this.MinHeight()
    endfunc

    wdg.Draw = function()
        set clip rect this.x, this.y, this.w, this.h
        if this.background
            set color this.background
            draw rect this.x, this.y, this.w, this.h, true
        endif

        set font this.fnt
        set color this.foreground
        if this.lines
            fh = fheight(this.fnt)
            if this.valign = 0  y = this.y + (this.h - fh*sizeof(this.lines))/2
            elseif this.valign < 0  y = this.y + this.padding
            else y = this.y + this.h - this.padding - fh*sizeof(this.lines)
            for i = 0 to sizeof(this.lines) - 1
                if this.halign = 0  x = this.x + (this.w - fwidth(this.fnt, this.lines[i]))/2
                elseif this.halign < 0  x = this.x + this.padding
                else  x = this.x + this.w - this.padding - fwidth(this.fnt, this.lines[i])
                set caret x, y + fh*i
                write this.lines[i]
            next
        else
            if this.halign = 0  x = this.x + (this.w - fwidth(this.fnt, this.txt))/2
            elseif this.halign < 0  x = this.x + this.padding
            else  x = this.x + this.w - this.padding - fwidth(this.fnt, this.txt)
    
            if this.valign = 0  y = this.y + (this.h - fheight(this.fnt))/2
            elseif this.valign < 0  y = this.y + this.padding
            else y = this.y + this.h - this.padding - fheight(this.fnt)
    
            set caret x, y
            write this.txt
        endif
        clear clip rect
    endfunc

    return wdg
endfunc

' Header
' ------
function Header(txt, w, h)
    wdg = Label(txt, w, h)
    wdg.fnt = vHeaderFont
    return wdg
endfunc

' TextButton
' ----------
function TextButton(txt, w, h, action)
    wdg = Widget()
    wdg.txt = txt
    wdg.ww = w
    wdg.wh = h
    wdg.background = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.foreground = vColors[COLOR_PRIMARY_TEXT]
    wdg.overBackground = unset
    wdg.overForeground = unset
    wdg.pressedBackground = unset
    wdg.pressedForeground = unset
    wdg.halign = ALIGN_CENTER
    wdg.valign = ALIGN_CENTER
    wdg.padding = vButtonPadding
    wdg.innerPadding = vTextButtonInnerPadding
    wdg.fnt = vDefaultFont
    wdg.mouseOver = false
    wdg.pressed = false
    wdg.trigger = 0
    wdg.triggerTime = 0
    wdg.Action = action

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetInnerPadding = GetInnerPadding
    wdg.SetInnerPadding = SetInnerPadding

    wdg.Resize = AtomResize

    wdg.SetText = function(txt)
        this.txt = txt
        this.MarkDirty()
    endfunc

    wdg.SetTrigger = function(value)
        this.trigger = max(value, 0)
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + (this.padding + this.innerPadding)*2
        else  return fwidth(this.fnt, this.txt) + (this.innerPadding + this.padding)*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else  return fheight(this.fnt) + (this.innerPadding + this.padding)*2
    endfunc

    wdg.MouseEnter = function()
        this.mouseOver = true
        this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        this.mouseOver = false
        this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        this.pressed = true
        this.triggerTime = clock()
        this.MarkDirty()
    endfunc

    wdg.MouseUp = function(x, y)
        if this.mouseOver and this.Action  this.Action(this)
        this.pressed = false
        this.MarkDirty()
    endfunc

    wdg.MousePressed = function(x, y)
        if this.trigger > 0 and this.mouseOver
            t = clock()
            if |t - this.triggerTime| >= this.trigger
                if this.Action  this.Action(this)
                this.triggerTime = t
            endif
        endif
    endfunc

    wdg.Draw = function()
        x = this.x + this.padding
        y = this.y + this.padding
        w = this.w - this.padding*2
        h = this.h - this.padding*2

        set clip rect x, y, w, h

        if this.ww <= 0  hip = this.innerPadding
        else hip = 0
        if this.wh <= 0  vip = this.innerPadding
        else vip = 0

        if this.halign = 0  txtX = x + (w - fwidth(this.fnt, this.txt))/2
        elseif this.halign < 0  txtX = x + hip
        else  txtX = x + w - fwidth(this.fnt, this.txt) - hip

        if this.valign = 0  txtY = y + (h - fheight(this.fnt))/2
        elseif this.valign < 0  txtY = y + vip
        else  txtY = y + h - fheight(this.fnt) - vip
      
        set caret txtX, txtY
        set font this.fnt

        if this.mouseOver
            if this.pressed
                if this.pressedBackground
                    set color this.pressedBackground
                    draw rect x, y, w, h, true
                elseif this.background
                    set color this.background[0]*vDarken, this.background[1]*vDarken, this.background[2]*vDarken
                    draw rect x, y, w, h, true
                endif
                if this.pressedForeground
                    set color this.pressedForeground
                else
                    set color this.foreground[0]*vDarken, this.foreground[1]*vDarken, this.foreground[2]*vDarken
                endif
            else
                if this.overBackground
                    set color this.overBackground
                    draw rect x, y, w, h, true
                elseif this.background
                    set color this.background[0]*vBrighten, this.background[1]*vBrighten, this.background[2]*vBrighten
                    draw rect x, y, w, h, true
                endif
                if this.overForeground
                    set color this.overForeground
                else
                    set color this.foreground[0]*vBrighten, this.foreground[1]*vBrighten, this.foreground[2]*vBrighten
                endif
            endif
        else
            if this.background
                set color this.background
                draw rect x, y, w, h, true
            endif
            set color this.foreground
        endif

        write this.txt

        clear clip rect

    endfunc

    return wdg
endfunc

function MenuTextButton(txt, extra, action)
    wdg = Widget()
    wdg.txt = txt
    wdg.extra = extra
    wdg.spacing = vMenuItemExtraSpacing
    wdg.ww = SIZE_EXPAND
    wdg.wh = SIZE_AUTO
    wdg.background = unset
    wdg.foreground = vColors[COLOR_MENU_TEXT]
    wdg.overBackground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.overForeground = vColors[COLOR_PRIMARY_TEXT]
    wdg.pressedBackground = unset
    wdg.pressedForeground = unset
    wdg.fnt = vDefaultFont
    wdg.valign = ALIGN_CENTER
    wdg.padding = vButtonPadding
    wdg.innerPadding = vTextButtonInnerPadding
    wdg.mouseOver = false
    wdg.pressed = false
    wdg.Action = action

    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        w = (this.innerPadding + this.padding)*2 + fwidth(this.fnt, this.txt)
        if this.extra  w = w + fwidth(this.fnt, this.extra) + this.spacing
        return w
    endfunc

    wdg.MinHeight = function()
        return fheight(this.fnt) + (this.innerPadding + this.padding)*2
    endfunc

    wdg.MouseEnter = function()
        this.mouseOver = true
        this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        this.mouseOver = false
        this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        this.pressed = true
        this.MarkDirty()
    endfunc

    wdg.MouseUp = function(x, y)
        if this.mouseOver and this.Action  this.Action(this)
        this.pressed = false
        this.MarkDirty()
    endfunc

    wdg.Draw = function()
        x = this.x + this.padding
        y = this.y + this.padding
        w = this.w - this.padding*2
        h = this.h - this.padding*2

        set clip rect x, y, w, h

        if this.mouseOver
            if this.pressed
                if this.pressedBackground
                    set color this.pressedBackground
                    draw rect x, y, w, h, true
                elseif this.background
                    set color this.background[0]*vDarken, this.background[1]*vDarken, this.background[2]*vDarken
                    draw rect x, y, w, h, true
                endif
                if this.pressedForeground
                    set color this.pressedForeground
                else
                    set color this.foreground[0]*vDarken, this.foreground[1]*vDarken, this.foreground[2]*vDarken
                endif
            else
                if this.overBackground
                    set color this.overBackground
                    draw rect x, y, w, h, true
                elseif this.background
                    set color this.background[0]*vBrighten, this.background[1]*vBrighten, this.background[2]*vBrighten
                    draw rect x, y, w, h, true
                endif
                if this.overForeground
                    set color this.overForeground
                else
                    set color this.foreground[0]*vBrighten, this.foreground[1]*vBrighten, this.foreground[2]*vBrighten
                endif
            endif
        else
            if this.background
                set color this.background
                draw rect x, y, w, h, true
            endif
            set color this.foreground
        endif


        set font this.fnt
        y = y + (h - fheight(this.fnt))/2
        set caret x + this.innerPadding, y
        set justification left
        write this.txt
        if this.extra
            set caret x + w - this.innerPadding, y
            set justification right
            write this.extra        
            set justification left
        endif

        clear clip rect
    endfunc

    return wdg
endfunc

' ImageButton
' -----------
function ImageButton(img, action)
    assert image(img)

    wdg = Widget()
    wdg.img = img
    ' SHOULD RELEASE THIS IMAGE IN DESTUCT THINGY! ADD!
    wdg.whiteImg = ImageMask(img)
    wdg.ww = width(img)
    wdg.wh = height(img)
    wdg.background = unset
    wdg.foreground = [255, 255, 255]
    wdg.padding = vButtonPadding
    wdg.mouseOver = false
    wdg.pressed = false
    wdg.trigger = 0
    wdg.triggerTime = 0
    wdg.Action = action

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding

    wdg.Resize = AtomResize

    wdg.SetTrigger = function(value)
        this.trigger = max(value, 0)
    endfunc

    wdg.MinWidth = function()
        return this.ww + this.padding*2
    endfunc

    wdg.MinHeight = function()
        return this.wh + this.padding*2
    endfunc

    wdg.Removed = function()
        if this.whiteImg  free image this.whiteImg
        WidgetRemoved(this)
    endfunc

    wdg.MouseEnter = function()
        this.mouseOver = true
        this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        this.mouseOver = false
        this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        this.pressed = true
        this.triggerTime = clock()
        this.MarkDirty()
    endfunc

    wdg.MouseUp = function(x, y)
        if this.mouseOver and this.Action  this.Action(this)
        this.pressed = false
        this.MarkDirty()
    endfunc

    wdg.MousePressed = function(x, y)
        if this.trigger > 0 and this.mouseOver
            t = clock()
            if |t - this.triggerTime| >= this.trigger
                if this.Action  this.Action(this)
                this.triggerTime = t
            endif
        endif
    endfunc

    wdg.Draw = function()
        if this.mouseOver
            if this.pressed
                intensity = vDarken
            else
                intensity = vBrighten
            endif
        else 
            intensity = 1
        endif
        if this.background
            set color this.background[0]*intensity, this.background[1]*intensity, this.background[2]*intensity
            draw rect this.x, this.y, this.w, this.h, true
        endif

        if intensity > 1
            set color this.foreground
            draw image this.img, this.x + this.padding, this.y + this.padding
            set color 255, 255, 255, (intensity - 1)*255
            draw image this.whiteImg, this.x + this.padding, this.y + this.padding
        else
            set color this.foreground[0]*intensity, this.foreground[1]*intensity, this.foreground[2]*intensity
            draw image this.img, this.x + this.padding, this.y + this.padding
        endif
    endfunc

    return wdg
endfunc

' LabledCheckBox
' --------------
function LabledCheckBox(txt, checked, action)
    wdg = HBox(SIZE_AUTO, SIZE_AUTO)
    wdg.spacing = vLabledCheckBoxSpacing
    wdg.valign = ALIGN_CENTER
    wdg.Add(CheckBox(checked, action))
    wdg.Add(Label(txt, SIZE_AUTO, SIZE_AUTO))
    wdg.checkBox = wdg.children[0]
    wdg.label = wdg.children[1]

    wdg.GetCheckBox = function()
        return this.checkBox
    endfunc

    wdg.GetLabel = function()
        return this.label
    endfunc

    return wdg
endfunc

' CheckBox
' --------
function CheckBox(checked, action)
    wdg = Widget()
    wdg.ww = vCheckBoxSize
    wdg.wh = vCheckBoxSize
    wdg.border = 1
    wdg.background = unset
    wdg.foreground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.borderColor = vColors[COLOR_BORDER]
    wdg.padding = vCheckBoxPadding
    wdg.checked = checked    
    wdg.mouseOver = false
    wdg.Action = action

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder

    wdg.Resize = AtomResize

    wdg.IsChecked = function()
        return this.checked
    endfunc

    wdg.SetChecked = function(value)
        if this.checked <> value
            this.checked = value
            this.MarkDirty()
        endif
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 14 + this.padding*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else  return 14 + this.padding*2
    endfunc

    wdg.MouseEnter = function()
        this.mouseOver = true
        this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        this.mouseOver = false
        this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        this.checked = not this.checked
        if this.Action  this.Action(this, this.checked)
        this.MarkDirty()
    endfunc

    wdg.Draw = function()
        if this.mouseOver  intensity = vBrighten
        else  intensity = 1
        x = this.x + this.padding
        w = this.w - this.padding*2
        y = this.y + this.padding
        h = this.h - this.padding*2
        if this.background
            set color this.background[0]*intensity, this.background[1]*intensity, this.background[2]*intensity
            draw rect this.x, this.y, this.w, this.h, true
        endif
        if this.border > 0 and this.borderColor
            set color this.borderColor[0]*intensity, this.borderColor[1]*intensity, this.borderColor[2]*intensity
            for i = 0 to this.border - 1
                draw rect x + i, y + i, w - i*2, h - i*2, false
            next
        endif
        if this.checked
            set color this.foreground[0]*intensity, this.foreground[1]*intensity, this.foreground[2]*intensity
            draw rect x + this.border + 2, y + this.border + 2, w - (this.border + 2)*2, h - (this.border + 2)*2, true
        endif
    endfunc
    
    return wdg
endfunc

' LabledRadioButton
' -----------------
function LabledRadioButton(group, txt, checked, action)
    wdg = HBox(SIZE_AUTO, SIZE_AUTO)
    wdg.spacing = vLabledCheckBoxSpacing
    wdg.valign = ALIGN_CENTER
    wdg.Add(RadioButton(group, checked, action))
    wdg.Add(Label(txt, SIZE_AUTO, SIZE_AUTO))
    wdg.radioButton = wdg.children[0]
    wdg.label = wdg.children[1]

    wdg.GetRadioButton = function()
        return this.radioButton
    endfunc

    wdg.GetLabel = function()
        return this.label
    endfunc

    return wdg
endfunc

' RadioButton
' -----------
function RadioButton(group, checked, action)
    wdg = Widget()

    wdg.group = str(group)
    if not key(vRadioButtonGroups, wdg.group) vRadioButtonGroups[wdg.group] = []
    AddToList(vRadioButtonGroups[wdg.group], wdg)
    wdg.ww = vRadioButtonSize
    wdg.wh = vRadioButtonSize
    wdg.border = 1 ' > 1 treated as 1, graphical limitations ...
    wdg.background = unset
    wdg.foreground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.borderColor = vColors[COLOR_BORDER]
    wdg.padding = vCheckBoxPadding
    if checked  foreach rb in vRadioButtonGroups[wdg.group]  rb.checked = false
    wdg.checked = checked
    wdg.mouseOver = false
    wdg.Action = action

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding

    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 14 + this.padding*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else  return 14 + this.padding*2
    endfunc

    wdg.MouseEnter = function()
        this.mouseOver = true
        this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        this.mouseOver = false
        this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        if not this.checked
            foreach rb in vRadioButtonGroups[this.group]
                if rb.checked
                    rb.checked = false
                    rb.MarkDirty()
                endif
            next
            this.checked = true
            if this.Action  this.Action(this, IndexOf(vRadioButtonGroups[this.group], this))
            this.MarkDirty()
        endif
    endfunc

    wdg.Draw = function()
        if this.mouseOver  intensity = vBrighten
        else  intensity = 1
        x = this.x + this.padding
        w = this.w - this.padding*2
        y = this.y + this.padding
        h = this.h - this.padding*2
        if this.background
            set color this.background[0]*intensity, this.background[1]*intensity, this.background[2]*intensity
            draw rect this.x, this.y, this.w, this.h, true
        endif
        if this.border > 0 and this.borderColor
            set color this.borderColor[0]*intensity, this.borderColor[1]*intensity, this.borderColor[2]*intensity
            draw ellipse x + w/2, y + h/2, w/2, h/2, false
        endif
        if this.checked
            set color this.foreground[0]*intensity, this.foreground[1]*intensity, this.foreground[2]*intensity
            draw ellipse x + w/2, y + h/2, w/2 - 3, h/2 - 3, true
        endif
    endfunc
    
    return wdg
endfunc

' SelectedRadioButton
' -------------------
' Return selected radio button in group.
function SelectedRadioButton(group)
    if key(vRadioButtonGroups, group) and sizeof(vRadioButtonGroups[group])
        for i = 0 to sizeof(vRadioButtonGroups[group]) - 1
            if vRadioButtonGroups[group][i].checked  return vRadioButtonGroups[group][i]
        next
    endif
    return unset
endfunc

' SelectedRadioButtonIndex
' ------------------------
' Return selected radio button index in group.
function SelectedRadioButtonIndex(group)
    if key(vRadioButtonGroups, group) and sizeof(vRadioButtonGroups[group])
        for i = 0 to sizeof(vRadioButtonGroups[group]) - 1
            if vRadioButtonGroups[group][i].checked  return i
        next
    endif
    return -1
endfunc

' SelectRadioButton
' -----------------
' Select radio button without performing action
function SelectRadioButton(group, rb)
    if key(vRadioButtonGroups, group) and sizeof(vRadioButtonGroups[group])
        foreach v in vRadioButtonGroups[group]
            v.checked = v = rb
            v.MarkDirty()
        next
    endif
endfunc

' SelectRadioButtonIndex
' ----------------------
' Select radio button by index without performing action.
function SelectRadioButtonIndex(group, index)
    if key(vRadioButtonGroups, group) and sizeof(vRadioButtonGroups[group])
        foreach i, rb in vRadioButtonGroups[group]
            rb.checked = i = index
            rb.MarkDirty()
        next
    endif
endfunc

function Menu(action)
    menu = Box(SIZE_AUTO, SIZE_AUTO)
    menu.padding = 7
    menu.border = 1
    menu.background = vColors[COLOR_MENU_BACKGROUND]
    menu.borderColor = vColors[COLOR_BORDER]
    menu.shadow = vMenuShadow
    menu.shadowColor = vColors[COLOR_SHADOW]
    menu.items = VBox(SIZE_AUTO, SIZE_AUTO)
    menu.items.spacing = 0
    menu.Add(menu.items)
    menu.itemCount = 0    
    menu.Action = action

    menu.Close = function(wdg, index)
        ' Not sure about this one, hack.
        if key(this, "menuBar")
            this.menuBar.activeMenu = unset
            this.menuBar.UnHighlight()
        endif
        if typeof(index) and this.Action this.Action(this, index)
    endfunc

    menu.Add = function(item, extra)
        if typeof(item) = TYPE_STRING
            btn = MenuTextButton(item, extra, function(wdg)                    
                    ClosePopup(wdg.menuItemIndex)
                endfunc)
            btn.menuItemIndex = this.itemCount
            this.itemCount = this.itemCount + 1
            this.items.Add(btn)
        else
            this.items.Add(item)
        endif
    endfunc
    
    return menu
endfunc

' ComboBox
' --------
function ComboBox(w, items, action)
    cb = HBox(SIZE_AUTO, SIZE_AUTO)
    cb.background = vColors[COLOR_MENU_BACKGROUND]
    cb.border = 1
    cb.borderInside = true
    cb.valign = ALIGN_CENTER
    cb.Action = action
    cb.list = items
    cb.displayField = unset
    cb.selectedIndex = -1
    cb.defaultText = "Select"
    cb.Add(Label(cb.defaultText, w, SIZE_EXPAND))
    cb.children[0].foreground = vColors[COLOR_MENU_TEXT]
    cb.children[0].padding = 4
    btn = TextButton("+",
            max(fwidth(vDefaultFont, "+"), fwidth(vDefaultFont, "-")), SIZE_EXPAND,
            function(wdg)
                wdg.SetText("-")
                wdg.comboBox.Open()
            endfunc)
    btn.comboBox = cb
    cb.Add(btn)

    cb.SetDefaultText = function(txt)
        this.defaultText = txt
        if this.selectedIndex < 0
            this.children[0].SetText(this.defaultText)
        endif
    endfunc

    cb.SetDisplayField = function(df)
        this.displayField = df
    endfunc

    cb.Open = function()
        pad = 2 ' popups border and padding
        ' probably should remove button width?
        popup = VBox(this.children[0].w - pad*2, SIZE_AUTO)
        popup.background = vColors[COLOR_MENU_BACKGROUND]
        popup.border = 1
        popup.borderColor = vColors[COLOR_BORDER]
        popup.shadow = vComboBoxShadow
        maxW = 0
        if this.list and sizeof(this.list) > 0
            for i = 0 to sizeof(this.list) - 1
                btn = MenuTextButton(this.GetItemLabel(i), unset, function(wdg)
                        ClosePopup(wdg.comboBoxItemIndex)
                    endfunc)
                btn.comboBoxItemIndex = i 
                maxW = max(maxW, btn.MinWidth())
                popup.Add(btn)
            next
        endif
        popup.ww = max(popup.ww, maxW)
        popup.x = this.x + this.padding
        popup.y = this.y + this.h - this.padding - this.border
        popup.padding = 2
        popup.comboBox = this
        popup.Resize(SIZE_AUTO, SIZE_AUTO)
        ShowPopup(popup, POPUP_CLOSE, function(popup, msg)
                cb = popup.comboBox
                cb.children[1].SetText("+")
                if typeof(msg)
                    cb.selectedIndex = msg
                    cb.children[0].SetText(cb.GetItemLabel(msg))
                    if cb.Action  cb.Action(cb, msg)
                endif
            endfunc)
    endfunc    

    cb.GetItemLabel = function(index)
        if typeof(this.displayField)
            if typeof(this.list[index][this.displayField]) = TYPE_FUNCTION
                return this.list[index][this.displayField]()
            else
                return this.list[index][this.displayField]
            endif
        else
            return this.list[index]
        endif
    endfunc

    cb.SelectIndex = function(index)
        if index < 0 or index >= sizeof(this.list)
            this.selectedIndex = -1
            this.children[0].SetText(this.defaultText)
        else
            this.selectedIndex = index
            this.children[0].SetText(this.GetItemLabel(index))
        endif
    endfunc

    cb.SelectItem = function(item)
        didSet = false
        if sizeof(this.list)
            for i = 0 to sizeof(this.list) - 1
                if this.list[i] = item
                    this.selectedIndex = i
                    this.children[0].SetText(this.GetItemLabel(i))
                    didSet = true
                    return
                endif
            next
        endif
        this.selectedIndex = -1
        this.children[0].SetText(this.defaultText)
    endfunc

    cb.GetSelectedIndex = function()
        return this.selectedIndex
    endfunc

    cb.GetSelectedItem = function()
        if this.selectedIndex >= 0 and this.selectedIndex < sizeof(this.list)
            return this.list[this.selectedIndex]
        else
            return unset
        endif
    endfunc

    return cb
endfunc

function HDivider(h, padding)
    wdg = Widget()
    wdg.foreground = vColors[COLOR_LIGHT_BORDER]
    wdg.padding = padding
    wdg.ww = SIZE_EXPAND
    wdg.wh = h

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    
    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 1
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else return 1
    endfunc

    wdg.Draw = function()
        if this.foreground
            set color this.foreground
            ' Hm .. skip padding horizontally?
            draw rect this.x, this.y + this.padding, this.w, this.h - this.padding*2, true
        endif
    endfunc

    return wdg
endfunc

function VDivider(w, padding)
    wdg = Widget()
    wdg.foreground = vColors[COLOR_LIGHT_BORDER]
    wdg.padding = padding
    wdg.ww = w
    wdg.wh = SIZE_EXPAND

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    
    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 1
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else return 1
    endfunc

    wdg.Draw = function()
        set color this.foreground
        draw rect this.x + this.padding, this.y, this.w - this.padding*2, this.h, true
    endfunc

    return wdg
endfunc


' MenuBar
' -------
function MenuBar()
    menuBar = VBox(SIZE_EXPAND, SIZE_AUTO)
    menuBar.background = vColors[COLOR_MENUBAR_BACKGROUND]

    menuBar.primaryBg = vColors[COLOR_PRIMARY_BACKGROUND]
    menuBar.primaryText = vColors[COLOR_PRIMARY_TEXT]
    menuBar.menuBarText = vColors[COLOR_MENUBAR_TEXT]
    menuBar.items = HBox(SIZE_EXPAND, SIZE_AUTO)
    menuBar.items.spacing = 7
    menuBar.items.padding = 2
    menuBar.padding = 0
    menuBar.activeMenu = unset
    menuBar.Add(menuBar.items)
    menuBar.Add(HDivider(1, 0))

    menuBar.Add = function(label, menu)
        btn = TextButton(label, SIZE_AUTO, SIZE_AUTO, function(wdg)
                if this.menuBar.activeMenu = this.menu  return
                if wdg.menu
                    wdg.menu.x = wdg.x
                    wdg.menu.y = wdg.y + wdg.h
                    wdg.menu.Resize(SIZE_AUTO, SIZE_AUTO)
                    this.background = this.menuBar.primaryBg 'vColors[COLOR_PRIMARY_BACKGROUND]
                    this.foreground = this.menuBar.primaryText 'vColors[COLOR_PRIMARY_TEXT]
                    this.MarkDirty()
                    this.menuBar.activeMenu = this.menu
                    ShowPopup(wdg.menu, POPUP_CLOSE, wdg.menu.Close)
                    SetFocus(this.menuBar)                    
                endif
            endfunc)
        btn.MouseEnter_ = btn.MouseEnter
        btn.MouseEnter = function()
                this.MouseEnter_()
                if this.menuBar.activeMenu and this.menuBar.activeMenu <> this.menu
                    ClosePopup(unset)
                    this.Action(this)
                endif
            endfunc
        btn.background = unset
        btn.foreground = vColors[COLOR_MENUBAR_TEXT]
        btn.overBackground = vColors[COLOR_PRIMARY_BACKGROUND]
        btn.overForeground = vColors[COLOR_PRIMARY_TEXT]
        btn.pressedBackground = unset
        btn.pressedForeground = unset
        btn.fnt = vDefaultFont
        btn.halign = ALIGN_LEFT

        menu.menuBar = this
        btn.menuBar = this
        btn.menu = menu
        menu.friend = this
        
        this.items.Add(btn)
    endfunc    

    menuBar.UnHighlight = function()
        foreach item in this.items.children
            item.background = unset
            item.foreground = this.menuBarText ' vColors[COLOR_MENUBAR_TEXT]
            item.MarkDirty()
        next
    endfunc

    menuBar.KeyDown = function(c)
        if c = KEY_ESCAPE  ClosePopup(unset)
        'if c = KEY_RETURN
            ' Find menu with item where mouseOver.
        'endif
    endfunc

    ' Switch menu with arrow keys left and right.
    ' Too many weird bugs when trying to "hack" a fake mouse behavior, disabling.
    menuBar.Update_ = function()
        function OverNone(list)
            foreach item in list  if item.mouseOver  return false
            return true
        endfunc

        function ActiveMenuIndex(list, am)
            for i = 0 to sizeof(list) - 1  if list[i].menu = am  break
            return i
        endfunc

        if this.activeMenu
            ' Switch menu with left/right arrow keys.
            if keydown(KEY_LEFT, true)
                ClearMouse()
                if OverNone(this.items.children)
                    i = ActiveMenuIndex(this.items.children, this.activeMenu)
                    count = sizeof(this.items.children)
                    if i < count
                        ClosePopup(unset)
                        this.items.children[(i - 1)%count].Action(this.items.children[(i - 1)%count]) 
                    endif
                endif
            elseif keydown(KEY_RIGHT, true)
                ClearMouse()
                if OverNone(this.items.children)
                    i = ActiveMenuIndex(this.items.children, this.activeMenu)
                    count = sizeof(this.items.children)
                    if i < count
                        ClosePopup(unset)
                        this.items.children[(i + 1)%count].Action(this.items.children[(i + 1)%count]) 
                    endif
                endif
            ' Switch menu item with up/down arrow keys.
            else if keydown(KEY_UP, true)
                ' Find item with mouseOver
                ClearMouse()
                items = this.activeMenu.items.children
                count = sizeof(items)
                if count
                    for i = 0 to sizeof(items) - 1  if items[i].MouseEnter and items[i].mouseOver  break
                    if i < count
                        do
                            i = i - 1
                        until items[i%count].MouseEnter
                        items[i%count].MouseEnter()
                        vMouseOverWdg = items[i%count]
                    elseif items[count - 1].MouseEnter
                        items[count - 1].MouseEnter()
                        vMouseOverWdg = items[count - 1]
                    endif
                endif
            else if keydown(KEY_DOWN, true)
                ClearMouse()
                items = this.activeMenu.items.children
                count = sizeof(items)
                if count
                    for i = 0 to sizeof(items) - 1  if items[i].MouseEnter and items[i].mouseOver  break
                    if i < count
                        do
                            i = i + 1
                        until items[i%count].MouseEnter
                        items[i%count].MouseEnter()
                        vMouseOverWdg = items[i%count]
                    elseif items[count - 1].MouseEnter
                        items[0].MouseEnter()
                        vMouseOverWdg = items[0]
                    endif
                endif
            endif         
        endif
    endfunc

    return menuBar
endfunc

' Image
' -----
function Image(img)
    wdg = Widget()
    wdg.img = img
    wdg.cel = 0
    wdg.DrawAction = unset
    wdg.Resize = AtomResize
    wdg.foreground = [255, 255, 255]
    
    wdg.GetImage = function()
        return this.img
    endfunc

    wdg.SetCell = function(cell)
        this.cel = cell
    endfunc

    wdg.SetMouseDownAction = function(action)
        this.MouseDown = action
    endfunc

    wdg.SetMouseUpAction = function(action)
        this.MouseUp = action
    endfunc

    wdg.SetMouseMoveAction = function(action)
        this.MouseMove = action
    endfunc

    wdg.SetMouseDragAction = function(action)
        this.MouseDrag = action
    endfunc

    wdg.SetDrawAction = function(action)
        this.DrawAction = action
    endfunc

    wdg.MinWidth = function()
        return width(this.img)
    endfunc

    wdg.MinHeight = function()
        return height(this.img)
    endfunc

    wdg.Draw = function()
        set clip rect this.x, this.y, this.w, this.h
        set color this.foreground
        draw image this.img, this.x, this.y, this.cel
        if this.DrawAction
            set color 255, 255, 255
            this.DrawAction(this.x, this.y, this.w, this.h)
        endif
        clear clip rect
    endfunc

    return wdg
endfunc

' Canvas
' ------
function Canvas(w, h)
    wdg = Widget()
    wdg.ww = w
    wdg.wh = h
    wdg.DrawAction = unset
    wdg.Resize = AtomResize

    wdg.SetMouseEnterAction = function(action)
        this.MouseEnter = action
    endfunc
    
    wdg.SetMouseLeaveAction = function(action)
        this.MouseLeave = action
    endfunc

    wdg.SetMouseDownAction = function(action)
        this.MouseDown = action
    endfunc

    wdg.SetMouseUpAction = function(action)
        this.MouseUp = action
    endfunc

    wdg.SetMouseMoveAction = function(action)
        this.MouseMove = action
    endfunc

    wdg.SetMouseDragAction = function(action)
        this.MouseDrag = action
    endfunc

    wdg.SetDrawAction = function(action)
        this.DrawAction = action
    endfunc

    wdg.MinWidth = function()
        return max(this.ww, 0)
    endfunc

    wdg.MinHeight = function()
        return max(this.wh, 0)
    endfunc

    wdg.Draw = function()
        set clip rect this.x, this.y, this.w, this.h
        if this.background
            set color this.background
            draw rect this.x, this.y, this.w, this.h, true
        endif
        if this.DrawAction  this.DrawAction(this.x, this.y, this.w, this.h)
        clear clip rect
    endfunc

    return wdg    
endfunc

' HorizontalSlider
' ----------------
function HorizontalSlider(w, minValue, maxValue, action)
    wdg = Widget()
    wdg.ww = w
    wdg.wh = 16
    wdg.bw = 16
    wdg.padding = 2
    wdg.background = unset
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.foreground = GetColor(COLOR_PRIMARY_BACKGROUND)
    wdg.minValue = minValue
    wdg.maxValue = maxValue
    wdg.param = 0.5
    wdg.overBar = false
    wdg.dragBar = false
    wdg.dragOffset = 0
    wdg.Action = action
    wdg.Resize = AtomResize

    wdg.GetValue = function()
        return this.minValue + this.param*(this.maxValue - this.minValue)
    endfunc

    wdg.SetValue = function(value)
        this.param = min(max((value - this.minValue)/(this.maxValue - this.minValue), 0), 1)
        this.MarkDirty()
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 32 + this.padding*2
    endfunc

    wdg.MinHeight = function()
        return this.wh + this.padding*2
    endfunc

    wdg.MouseMove = function(x, y)
        xbar = this.padding + this.param*(this.w - this.padding*2 - this.bw)
        ob = this.overBar
        this.overBar = x >= xbar and x < xbar + this.bw
        if ob <> this.overBar  this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        if this.overBar
            this.overBar = false
            this.MarkDirty()
        endif
    endfunc

    wdg.MouseDown = function(x, y)
        if this.overBar
            this.dragOffset = (this.padding +
                    this.param*(this.w - this.padding*2 - this.bw) + this.bw/2) - x
        else
            this.param = min(max((x - this.padding - this.bw/2)/
                    (this.w - this.padding*2 - this.bw), 0), 1)
            this.dragOffset = 0
            if this.Action  this.Action(this,
                    this.minValue + this.param*(this.maxValue - this.minValue))
        endif
        this.dragBar = true
        this.MarkDirty()
    endfunc

    wdg.MouseDrag = function(x, y)
        if this.dragBar
            this.param = min(max((x + this.dragOffset - this.padding - this.bw/2)/
                    (this.w - this.padding*2 - this.bw), 0), 1)
            if this.Action  this.Action(this,
                    this.minValue + this.param*(this.maxValue - this.minValue))
            this.MarkDirty()
        endif
    endfunc

    wdg.MouseUp = function(x, y)
        if this.dragBar
            this.dragBar = false
            this.MarkDirty()
        endif
    endfunc

    wdg.Draw = function()
        x = this.x + this.padding
        w = this.w - this.padding*2
        y = this.y + this.padding
        h = this.h - this.padding*2

        if this.background
            set color this.background
            draw rect x, y, w, h, true
        endif
        hh = this.h/2
        set color this.borderColor
        draw rect x, this.y + hh - 1, w, 2, true
        draw rect x, this.y + hh - 5, 2, 10, true
        draw rect x + w - 2, this.y + hh - 5, 2, 10, true

        if this.dragBar
            set color this.foreground[0]*vDarken, this.foreground[1]*vDarken,
                    this.foreground[2]*vDarken
        elseif this.overBar
            set color this.foreground[0]*vBrighten, this.foreground[1]*vBrighten,
                    this.foreground[2]*vBrighten
        else
            set color this.foreground
        endif
        draw rect x + this.param*(w - this.bw), y, this.bw, h, true
    endfunc
    
    return wdg
endfunc

' VerticalSlider
' --------------
function VerticalSlider(h, minValue, maxValue, action)
    wdg = Widget()
    wdg.ww = 16
    wdg.wh = h
    wdg.bh = 16
    wdg.padding = 2
    wdg.background = unset
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.foreground = GetColor(COLOR_PRIMARY_BACKGROUND)
    wdg.minValue = minValue
    wdg.maxValue = maxValue
    wdg.param = 0.5
    wdg.overBar = false
    wdg.dragBar = false
    wdg.dragOffset = 0
    wdg.Action = action
    wdg.Resize = AtomResize

    wdg.GetValue = function()
        return this.minValue + this.param*(this.maxValue - this.minValue)
    endfunc

    wdg.SetValue = function(value)
        this.param = min(max((value - this.minValue)/(this.maxValue - this.minValue), 0), 1)
        this.MarkDirty()
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else  return 32 + this.padding*2
    endfunc

    wdg.MinWidth = function()
        return this.ww + this.padding*2
    endfunc

    wdg.MouseMove = function(x, y)
        ybar = this.padding + this.param*(this.h - this.padding*2 - this.bh)
        ob = this.overBar
        this.overBar = y >= ybar and y < ybar + this.bh
        if ob <> this.overBar  this.MarkDirty()
    endfunc

    wdg.MouseLeave = function()
        if this.overBar
            this.overBar = false
            this.MarkDirty()
        endif
    endfunc

    wdg.MouseDown = function(x, y)
        if this.overBar
            this.dragOffset = (this.padding +
                    this.param*(this.h - this.padding*2 - this.bh) + this.bh/2) - y
        else
            this.param = min(max((y - this.padding - this.bh/2)/
                    (this.h - this.padding*2 - this.bh), 0), 1)
            this.dragOffset = 0
            if this.Action  this.Action(this,
                    this.minValue + this.param*(this.maxValue - this.minValue))
        endif
        this.dragBar = true
        this.MarkDirty()
    endfunc

    wdg.MouseDrag = function(x, y)
        if this.dragBar
            this.param = min(max((y + this.dragOffset - this.padding - this.bh/2)/
                    (this.h - this.padding*2 - this.bh), 0), 1)
            if this.Action  this.Action(this,
                    this.minValue + this.param*(this.maxValue - this.minValue))
            this.MarkDirty()
        endif
    endfunc

    wdg.MouseUp = function(x, y)
        if this.dragBar
            this.dragBar = false
            this.MarkDirty()
        endif
    endfunc

    wdg.Draw = function()
        x = this.x + this.padding
        w = this.w - this.padding*2
        y = this.y + this.padding
        h = this.h - this.padding*2

        if this.background
            set color this.background
            draw rect x, y, w, h, true
        endif
        hw = this.w/2
        set color this.borderColor
        draw rect this.x + hw - 1, y, 2, h, true
        draw rect this.x + hw - 5, y, 10, 2, true
        draw rect this.x + hw - 5, y + h - 2, 10, 2, true

        if this.dragBar
            set color this.foreground[0]*vDarken, this.foreground[1]*vDarken,
                    this.foreground[2]*vDarken
        elseif this.overBar
            set color this.foreground[0]*vBrighten, this.foreground[1]*vBrighten,
                    this.foreground[2]*vBrighten
        else
            set color this.foreground
        endif
        draw rect x, y + this.param*(h - this.bh), w, this.bh, true
    endfunc
    
    return wdg
endfunc

' ColorPicker
' -----------
function ColorPicker(action)
    wdg = HBox(SIZE_AUTO, SIZE_AUTO)
    wdg.padding = 2
    wdg.spacing = 4
    wdg.res = 128
    wdg.rgb = dim(3)
    wdg.hsv = dim(3)
    wdg.Action = action

    ' Picker box.
    pickerBox = VBox(SIZE_AUTO, SIZE_AUTO)
    pickerBox.halign = ALIGN_RIGHT
    pickerBox.spacing = 6
    wdg.Add(pickerBox)

    wdg.hsImage = Image(CreateHueSaturationImage(wdg.res))
    wdg.hsImage.colorPicker = wdg
    action = function(x, y)
        h = 360*x/width(this.img)
        s = y/height(this.img)
        this.colorPicker.SetColorHSV_(h, s, this.colorPicker.hsv[2])
    endfunc
    wdg.hsImage.SetMouseDownAction(action)
    wdg.hsImage.SetMouseDragAction(action)
    wdg.hsImage.SetDrawAction(function(x, y, w, h)
        set clip rect x, y, w, h
        cx = x + (this.colorPicker.hsv[0]/360)*w
        cy = y + this.colorPicker.hsv[1]*h
        set color 0, 0, 0, 64
        draw line cx, y, cx, y + h
        draw line x, cy, x + w, cy
        set color 255, 255, 255 'this.colorPicker.rgb        
        draw ellipse cx, cy, 3, 3, true
        set color 0, 0, 0
        draw ellipse cx, cy, 3, 3, false
        clear clip rect
    endfunc)
    pickerBox.Add(wdg.hsImage)

    wdg.vImage = Image(createimage(wdg.res, wdg.res/8))
    wdg.vImage.colorPicker = wdg
    action = function(x, y)
        v = x/width(this.img)
        this.colorPicker.SetColorHSV_(this.colorPicker.hsv[0], this.colorPicker.hsv[1], v)
    endfunc
    wdg.vImage.SetMouseDownAction(action)
    wdg.vImage.SetMouseDragAction(action)
    wdg.vImage.SetDrawAction(function(x, y, w, h)
        set clip rect x, y, w, h
        cx = x + this.colorPicker.hsv[2]*w
        set color 255, 255, 255
        draw rect cx - 1, y, 3, h, true
        set color 0, 0, 0
        draw line cx - 1, y, cx - 1, y + h
        draw line cx + 1, y, cx + 1, y + h
        clear clip rect
    endfunc)
    pickerBox.Add(wdg.vImage)

    wdg.ccBox = VBox(wdg.res, wdg.res/8)
    wdg.ccBox.SetBackground([0, 0, 0])
    pickerBox.Add(wdg.ccBox)

    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.spacing = 4
    hb.Add(Label("HTML", SIZE_AUTO, SIZE_AUTO))
    wdg.htmlEntry = TextEntry(56, false)
    wdg.htmlEntry.colorPicker = wdg
    wdg.htmlEntry.SetValueChangedAction(function(wdg, value)
            rgb = HexToRGB(value)
            if rgb  wdg.colorPicker.SetColorRGB_(rgb[0], rgb[1], rgb[2])
            else  wdg.SetText(RGBToHex(wdg.colorPicker.rgb[0], wdg.colorPicker.rgb[1],
                    wdg.colorPicker.rgb[2]))
        endfunc)
    wdg.htmlEntry.SetTabAction(function(wdg); SetFocus(wdg.colorPicker.rEntry); endfunc)
    wdg.htmlEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.htmlEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.htmlEntry)
    pickerBox.Add(hb)

    entryBox = VBox(SIZE_AUTO, SIZE_AUTO)
    entryBox.halign = ALIGN_RIGHT
    entryBox.spacing = 4
    wdg.Add(entryBox)

    ' RGB.
    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("R:", SIZE_AUTO, SIZE_AUTO))
    wdg.rSlider = HorizontalSlider(100, 0, 255, function(wdg, value)
            wdg.colorPicker.SetColorRGB_(value, wdg.colorPicker.rgb[1], wdg.colorPicker.rgb[2])
        endfunc)
    wdg.rSlider.colorPicker = wdg
    hb.Add(wdg.rSlider)
    wdg.rEntry = TextEntry(32, true)
    wdg.rEntry.colorPicker = wdg
    wdg.rEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorRGB_(value, wdg.colorPicker.rgb[1], wdg.colorPicker.rgb[2])
        endfunc)
    wdg.rEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.gEntry); endfunc)
    wdg.rEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.rEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.rEntry)
    entryBox.Add(hb)        

    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("G:", SIZE_AUTO, SIZE_AUTO))
    wdg.gSlider = HorizontalSlider(100, 0, 255, function(wdg, value)
            wdg.colorPicker.SetColorRGB_(wdg.colorPicker.rgb[0], value, wdg.colorPicker.rgb[2])
        endfunc)
    wdg.gSlider.colorPicker = wdg
    hb.Add(wdg.gSlider)
    wdg.gEntry = TextEntry(32, true)
    wdg.gEntry.colorPicker = wdg
    wdg.gEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorRGB_(wdg.colorPicker.rgb[0], value, wdg.colorPicker.rgb[2])
        endfunc)
    wdg.gEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.bEntry); endfunc)
    wdg.gEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.gEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.gEntry)
    entryBox.Add(hb)        

    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("B:", SIZE_AUTO, SIZE_AUTO))
    wdg.bSlider = HorizontalSlider(100, 0, 255, function(wdg, value)
            wdg.colorPicker.SetColorRGB_(wdg.colorPicker.rgb[0], wdg.colorPicker.rgb[1], value)
        endfunc)
    wdg.bSlider.colorPicker = wdg
    hb.Add(wdg.bSlider)
    wdg.bEntry = TextEntry(32, true)
    wdg.bEntry.colorPicker = wdg
    wdg.bEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorRGB_(wdg.colorPicker.rgb[0], wdg.colorPicker.rgb[1], value)
        endfunc)
    wdg.bEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.hEntry); endfunc)
    wdg.bEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.bEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.bEntry)
    entryBox.Add(hb)        

    ' HSV.
    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("H:", SIZE_AUTO, SIZE_AUTO))
    wdg.hSlider = HorizontalSlider(100, 0, 360, function(wdg, value)
            wdg.colorPicker.SetColorHSV_(value, wdg.colorPicker.hsv[1], wdg.colorPicker.hsv[2])
        endfunc)
    wdg.hSlider.colorPicker = wdg
    hb.Add(wdg.hSlider)
    wdg.hEntry = TextEntry(32, true)
    wdg.hEntry.colorPicker = wdg
    wdg.hEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorHSV_(value, wdg.colorPicker.hsv[1], wdg.colorPicker.hsv[2])
        endfunc)
    wdg.hEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.sEntry); endfunc)
    wdg.hEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.hEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.hEntry)
    entryBox.Add(hb)        

    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("S:", SIZE_AUTO, SIZE_AUTO))
    wdg.sSlider = HorizontalSlider(100, 0, 100, function(wdg, value)
            wdg.colorPicker.SetColorHSV_(wdg.colorPicker.hsv[0], value/100, wdg.colorPicker.hsv[2])
        endfunc)
    wdg.sSlider.colorPicker = wdg
    hb.Add(wdg.sSlider)
    wdg.sEntry = TextEntry(32, true)
    wdg.sEntry.colorPicker = wdg
    wdg.sEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorHSV_(wdg.colorPicker.hsv[0], value/100, wdg.colorPicker.hsv[2])
        endfunc)
    wdg.sEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.vEntry); endfunc)
    wdg.sEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.sEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.sEntry)
    entryBox.Add(hb)        

    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.valign = ALIGN_CENTER
    hb.Add(Label("V:", SIZE_AUTO, SIZE_AUTO))
    wdg.vSlider = HorizontalSlider(100, 0, 100, function(wdg, value)
            wdg.colorPicker.SetColorHSV_(wdg.colorPicker.hsv[0], wdg.colorPicker.hsv[1], value/100)
        endfunc)
    wdg.vSlider.colorPicker = wdg
    hb.Add(wdg.vSlider)
    wdg.vEntry = TextEntry(32, true)
    wdg.vEntry.colorPicker = wdg
    wdg.vEntry.SetValueChangedAction(function(wdg, value)
            wdg.colorPicker.SetColorHSV_(wdg.colorPicker.hsv[0], wdg.colorPicker.hsv[1], value/100)
        endfunc)
    wdg.vEntry.SetTabAction(function(wdg); SetFocus(this.colorPicker.htmlEntry); endfunc)
    wdg.vEntry.SetReturnAction(function(wdg); SetFocus(unset); endfunc)
    wdg.vEntry.SetEscapeAction(function(wdg); SetFocus(unset); endfunc)
    hb.Add(wdg.vEntry)
    entryBox.Add(hb)        

    wdg.ColorChanged = function()
        DrawValueImage(this.vImage.GetImage(), this.hsv[0], this.hsv[1])
        this.ccBox.background[0] = this.rgb[0]
        this.ccBox.background[1] = this.rgb[1]
        this.ccBox.background[2] = this.rgb[2]
        this.hsImage.MarkDirty()
        this.vImage.MarkDirty()
        this.ccBox.MarkDirty()
        this.htmlEntry.SetText(RGBToHex(this.rgb[0], this.rgb[1], this.rgb[2]))
        this.rEntry.SetText(str(int(this.rgb[0])))
        this.gEntry.SetText(str(int(this.rgb[1])))
        this.bEntry.SetText(str(int(this.rgb[2])))
        this.hEntry.SetText(str(int(this.hsv[0])))
        this.sEntry.SetText(str(int(this.hsv[1]*100)))
        this.vEntry.SetText(str(int(this.hsv[2]*100)))
        this.rSlider.SetValue(this.rgb[0])
        this.gSlider.SetValue(this.rgb[1])
        this.bSlider.SetValue(this.rgb[2])
        this.hSlider.SetValue(this.hsv[0])
        this.sSlider.SetValue(100*this.hsv[1])
        this.vSlider.SetValue(100*this.hsv[2])
        this.MarkDirty()
    endfunc

    wdg.SetColorRGB = function(r, g, b)
        this.rgb[0] = min(max(r, 0), 255)
        this.rgb[1] = min(max(g, 0), 255)
        this.rgb[2] = min(max(b, 0), 255)
        RGBToHSV(this.hsv, this.rgb[0], this.rgb[1], this.rgb[2])
        this.ColorChanged()
    endfunc

    wdg.SetColorHSV = function(h, s, v)
        this.hsv[0] = min(max(h, 0), 360)
        this.hsv[1] = min(max(s, 0), 1)
        this.hsv[2] = min(max(v, 0), 1)
        HSVToRGB(this.rgb, this.hsv[0], this.hsv[1], this.hsv[2])
        this.ColorChanged()
    endfunc

    wdg.SetColorRGB_ = function(r, g, b)
        this.SetColorRGB(r, g, b)
        if this.Action  this.Action(this, int(this.rgb[0]), int(this.rgb[1]), int(this.rgb[2]))
    endfunc

    wdg.SetColorHSV_ = function(h, s, v)
        this.SetColorHSV(h, s, v)
        if this.Action  this.Action(this, int(this.rgb[0]), int(this.rgb[1]), int(this.rgb[2]))
    endfunc

    c = GetColor(COLOR_PRIMARY_BACKGROUND)
    
    wdg.SetColorRGB(c[0], c[1], c[2])

    return wdg

    function CreateHueSaturationImage(size)
        img = createimage(size, size)
        set image img
        rgb = []
        for h = 0 to size
            for s = 0 to size
                HSVToRGB(rgb, 360*h/size, s/size, 1)
                set color rgb
                set pixel h, s
            next
        next
        set image primary
        return img
    endfunc

    function DrawValueImage(img, h, s)
        imgW = width(img) - 1
        imgH = height(img)
        set image img
        rgb = []
        for x = 0 to imgW
            HSVToRGB(rgb, h, s, x/imgW)
            set color rgb
            draw line x, 0, x, imgH
        next
        set image primary
    endfunc
endfunc

' LineNumberBar
' -------------
function LineNumberBar(w, h)
    wdg = Widget()
    wdg.ww = w
    wdg.wh = h
    wdg.padding = 2
    wdg.border = 0
    wdg.start = 1
    wdg.background = vColors[COLOR_ED_LN_BACKGROUND] 'vColors[COLOR_LIGHT_BORDER]
    wdg.foreground = vColors[COLOR_ED_LN_TEXT] 'vColors[COLOR_BORDER]
    wdg.borderColor = vColors[COLOR_LIGHT_BORDER]
    wdg.fnt = vTextEditorFont
    wdg.charW = fwidth(wdg.fnt, " ")    

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder

    wdg.Resize = AtomResize

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + (this.padding + this.border)*2
        else  return this.charW*8 + (this.padding + this.border)*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + (this.padding + this.border)*2
        else  return (this.padding + this.border)*2
    endfunc

    wdg.SetStart = function(value)
        if value <> this.start
            this.start = value
            this.MarkDirty()
        endif
    endfunc

    wdg.Draw = function()
        if this.background
            set color this.background
            draw rect this.x, this.y, this.w, this.h, true
        endif
        'if this.border > 0 and this.borderColor
        '    set color this.borderColor[0], this.borderColor[1], this.borderColor[2]        
        '    x = this.x + this.w - this.padding - 1
        '    draw rect this.x + this.w - this.padding - this.border, this.y, this.border, this.h, true
        'endif
        set clip rect this.x + this.padding, this.y + this.padding, this.w - this.padding*2 - this.border, this.h - this.padding*2
        set font this.fnt
        set caret this.x + this.w - this.padding - this.charW - this.border*2, this.y + this.padding
        set justification right
        set color this.foreground
        count = int((this.h - this.padding*2)/fheight(this.fnt))
        value = this.start
        for i = 0 to count
            wln value
            value = value + 1
        next
        set justification left
        clear clip rect
    endfunc

    return wdg
endfunc

' TextEntry
' ---------
function TextEntry(w, numeric)
    wdg = Widget()
    wdg.ww = w
    wdg.wh = SIZE_AUTO
    wdg.padding = 2
    wdg.innerPadding = 2
    wdg.border = 1
    wdg.background = vColors[COLOR_ED_BACKGROUND]
    wdg.foreground = vColors[COLOR_ED_TEXT]
    wdg.selection = vColors[COLOR_ED_SELECTION]
    wdg.borderColor = vColors[COLOR_BORDER]
    wdg.wantsKeyboard = true
    wdg.hasFocus = false
    wdg.clickTimer = 0
    wdg.clickCount = 0
    wdg.isNum = numeric
    wdg.txt = ""
    wdg.orgTxt = ""
    wdg.caretX = 0
    wdg.caretBlinkTimer = 0
    wdg.caretBlinkDelay = vFps*2
    wdg.scrollX = 0
    wdg.selX = -1
    wdg.hasMSel = false
    wdg.fnt = vTextEntryFont
    wdg.charW = fwidth(wdg.fnt, " ")
    wdg.charH = fheight(wdg.fnt)
    wdg.tabSize = TAB_SIZE
    wdg.tab = ""
    for i = 1 to wdg.tabSize  wdg.tab = wdg.tab + " "

    ' Common properties.
    wdg.GetPadding = GetPadding
    wdg.SetPadding = SetPadding
    wdg.GetInnerPadding = GetInnerPadding
    wdg.SetInnerPadding = SetInnerPadding
    wdg.GetBorder = GetBorder
    wdg.SetBorder = SetBorder

    ' SetNumeric
    ' ----------
    wdg.SetNumeric = function(value)
        this.isNum = value
    endfunc    

    ' SetReturnAction
    ' ---------------
    wdg.SetReturnAction = function(cb)
        this.retCB = cb 
    endfunc

    ' SetEscapeAction
    ' ---------------    
    wdg.SetEscapeAction = function(cb)
        this.escCB = cb
    endfunc

    ' SetTabAction
    ' ------------
    wdg.SetTabAction = function(cb)
        this.tabCB = cb
    endfunc

    ' SetValueChangedAction
    ' ---------------------
    wdg.SetValueChangedAction = function(cb)
        this.vcCB = cb
    endfunc

    wdg.GetText = function()
        return this.txt
    endfunc

    wdg.SetText = function(txt)
        this.txt = str(txt)
        this.orgTxt = str(txt)
        this.caretX = len(this.txt)
        this.selX = -1
        this.hasMSel = false
        this.ScrollToCaret()
    endfunc

    wdg.Resize_ = AtomResize

    wdg.Resize = function(w, h)
        this.charW = fwidth(this.fnt, " ")
        this.charH = fheight(this.fnt)
        this.Resize_(w, h)
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + (this.padding + this.innerPadding + this.border)*2
        else return 64 + (this.padding + this.innerPadding + this.border)*2
    endfunc

    wdg.MinHeight = function()
        m = fheight(this.fnt) + (this.padding + this.innerPadding + this.border)*2
        if this.wh > 0  return max(m, this.wh + (this.padding + this.innerPadding + this.border)*2)
        else  return m
    endfunc

    wdg.RestoreText = function()
        if this.txt <> this.orgTxt
            this.txt = this.orgTxt
            this.caretX = len(this.txt)
            this.selX = -1
            this.hasMSel = false
            this.ScrollToCaret()
        endif
    endfunc

    wdg.GotFocus = function()
        this.orgTxt = this.txt
        this.hasFocus = true
        this.caretBlinkTimer = 0
        this.MarkDirty()
    endfunc

    wdg.LostFocus = function()
        this.hasFocus = false
        if this.caretBlinkTimer < this.caretBlinkDelay/2  this.MarkDirty()
        ' Actually ... yeah.
        if key(this, "vcCB") and this.txt <> this.orgTxt
            if this.isNum
                this.vcCB(this, float(this.txt))
            else
                this.vcCB(this, this.txt)
            endif
        endif
    endfunc

    ' SelectCurrentWord
    ' -----------------
    ' On double click.
    wdg.SelectCurrentWord = function()
        lineLen = len(this.txt)
        if this.caretX < lineLen
            c = asc(mid(this.txt, this.caretX))
            this.selX = this.caretX
            if IsAlphaOrDigit(c)
                while this.selX > 0 and IsAlphaOrDigit(asc(mid(this.txt, this.selX - 1)))  this.selX = this.selX - 1
                while this.caretX < lineLen and IsAlphaOrDigit(asc(mid(this.txt, this.caretX)))  this.caretX = this.caretX + 1
            else
                while this.selX > 0 and asc(mid(this.txt, this.selX - 1)) = c  this.selX = this.selX - 1
                while this.caretX < lineLen and asc(mid(this.txt, this.caretX)) = c  this.caretX = this.caretX + 1
            endif
        endif
    endfunc

    ' MouseDown
    ' ---------
    wdg.MouseDown = function(x, y)
        ' Check for double and triple clicks.
        t = clock()
        if |t - this.clickTimer| < 1000  this.clickCount = this.clickCount + 1
        else  this.clickCount = 1
        this.clickTimer = t

        cx = int((x - this.padding - this.innerPadding - this.border)/this.charW) + this.scrollX
        this.caretX = max(min(cx, len(this.txt)), 0)
        if this.clickCount = 1
            this.RemoveSelection()
            this.StartSelection()
        elseif this.clickCount = 2
            this.SelectCurrentWord()
        else
            this.SelectAll()
            this.clickCount = 0
        endif       
        this.caretBlinkTimer = 0
        this.hasMSel = true
        this.MarkDirty()
    endfunc

    ' MouseDrag
    ' ---------
    wdg.MouseDrag = function(x, y)
        cx = int((x - this.padding - this.innerPadding - this.border)/this.charW) + this.scrollX
        this.caretX = max(min(cx, len(this.txt)), 0)
        this.ScrollToCaret()
    endfunc

    ' MouseUp
    ' -------
    wdg.MouseUp = function(x, y)
        this.hasMSel = false
    endfunc

    ' StartSelection
    ' --------------
    wdg.StartSelection = function()
        if this.selX < 0  this.selX = this.caretX
    endfunc

    ' RemoveSelection
    ' ---------------
    wdg.RemoveSelection = function()
        this.selX = -1
    endfunc

    ' HasSelection
    ' ------------
    wdg.HasSelection = function()
        if this.selX < 0  return false
        if this.selX <> this.caretX  return true
        this.selX = -1
        return false
    endfunc

    ' GetSelection
    ' ------------
    wdg.GetSelection = function()
        if this.selX >= 0 and this.selX <> this.caretX
            cs = min(this.selX, this.caretX)
            ce = max(this.selX, this.caretX)
            return mid(this.txt, cs, ce - cs)
        else
            return ""
        endif
    endfunc

    ' CopySelection
    ' -------------
    wdg.CopySelection = function()
        s = this.GetSelection()
        if len(s)  set clipboard s
    endfunc

    ' DeleteSelection
    ' ---------------
    wdg.DeleteSelection = function()
        if this.selX < 0  return false

        cs = min(this.selX, this.caretX)
        ce = max(this.selX, this.caretX)
        if ce > cs
            this.txt = left(this.txt, cs) + right(this.txt, ce)    
            this.caretX = cs
            this.RemoveSelection()
            return true
        else
            this.RemoveSelection()
            return false
        endif
    endfunc

    ' PasteString_
    ' ------------
    wdg.PasteString_ = function(txt)
        if len(txt) and (this.isNum = false or .isNum = INTEGER and int(txt) > 0 or .isNum = FLOAT and float(txt) > 0) 
            l = left(this.txt, this.caretX)
            r = right(this.txt, this.caretX)
            n = instr(txt, chr(10))
            if n >= 0  txt = left(txt, n)
            txt = replace(txt, chr(9), this.tab)
            this.txt = l + txt + r
            this.caretX = this.caretX + len(txt)
        endif
    endfunc

    ' SelectAll
    ' ---------
    wdg.SelectAll = function()
        this.selX = 0
        this.caretX = len(this.txt)
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' AboutToMoveCaret
    ' ----------------
    ' Start or stop selection.
    wdg.AboutToMoveCaret = function()
        if keydown(KEY_SHIFT)  this.StartSelection()
        else  this.RemoveSelection()
    endfunc

    ' Draw
    ' ----
    wdg.Draw = function()
        if this.border > 0 and this.borderColor
            set color this.borderColor
            for i = 0 to this.border - 1
                draw rect this.x + this.padding + i, this.y + this.padding + i, this.w - (this.padding + i)*2, this.h - (this.padding + i)*2, false
            next
        endif
        x = this.x + this.padding + this.border
        y = this.y + this.padding + this.border
        w = this.w - (this.padding + this.border)*2
        h = this.h - (this.padding + this.border)*2
        if this.background
            set color this.background
            draw rect x, y, w, h, true
        endif

        set clip rect x, y, w, h

        x = x + this.innerPadding
        y = this.y + (this.h - this.charH)/2
        if this.selX >= 0 and this.selX <> this.caretX
            set color this.selection
            sx = min(this.selX, this.caretX)
            sw = |this.caretX - this.selX|
            draw rect x + (sx - this.scrollX)*this.charW, y, sw*this.charW, this.charH, true 
        endif

        set font this.fnt
        set color this.foreground
        set caret x - this.scrollX*this.charW, y
        write this.txt

        if this.hasFocus and this.caretBlinkTimer < this.caretBlinkDelay/2
            set caret x + (this.caretX - this.scrollX)*this.charW, y + 1
            write "_"
        endif

        clear clip rect
    endfunc

    ' Update
    ' ------
    wdg.Update = function()
        this.caretBlinkTimer = (this.caretBlinkTimer + 1)%this.caretBlinkDelay
        if this.caretBlinkTimer = 0 or this.caretBlinkTimer = int(this.caretBlinkDelay/2)  this.MarkDirty()
        if not keydown(KEY_CONTROL)
            if keydown(KEY_RIGHT, true)
                if this.caretX < len(this.txt)
                    this.AboutToMoveCaret()
                    this.caretX = this.caretX + 1
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_LEFT, true)
                if this.caretX > 0
                    this.AboutToMoveCaret()
                    this.caretX = this.caretX - 1
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_END, true)
                this.AboutToMoveCaret()
                this.caretX = len(this.txt)
                this.caretBlinkTimer = 0
                this.ScrollToCaret()
            elseif keydown(KEY_HOME, true)
                this.AboutToMoveCaret()
                this.caretX = 0
                this.caretBlinkTimer = 0
                this.ScrollToCaret()
            endif
        endif
    endfunc

    ' KeyDown
    ' -------
    wdg.KeyDown = function(c)
        shiftKey = keydown(KEY_SHIFT)
        ' Printable.
        if (this.isNum = false and c >= 32 and c <= 126) or
                (this.isNum = INTEGER and c >= 48 and c <= 57) or
                (this.isNum = FLOAT and ((c >= 48 and c <= 57) or (this.caretX > 0 and c = 46 and instr(this.txt, ".") < 0))) 
            this.DeleteSelection()
            this.txt = left(this.txt, this.caretX) + chr(c) + right(this.txt, this.caretX)
            this.caretX = this.caretX + 1
        ' Backspace.
        elseif c = 8
            if this.HasSelection()
                this.DeleteSelection()
            else
                if this.caretX > 0
                    this.txt = left(this.txt, this.caretX - 1) + right(this.txt, this.caretX)
                    this.caretX = this.caretX - 1
                endif
            endif
        ' Delete.
        elseif c = 127
            if this.HasSelection()
                this.DeleteSelection()
            else
                if this.caretX < len(this.txt)
                    this.txt = left(this.txt, this.caretX) + right(this.txt, this.caretX + 1)
                endif
            endif
        ' Enter
        elseif c = 13
            if key(this, "retCB")
                this.retCB(this)
            endif
        ' Tab.
        elseif c = 9
            if key(this, "tabCB")
                this.tabCB(this)
            endif
        ' Escape
        elseif c = KEY_ESCAPE
            if key(this, "escCB")
                this.escCB(this)
            endif
        endif
        this.ScrollToCaret()
    endfunc

    ' CommandKeyDown
    ' --------------
    wdg.CommandKeyDown = function()
        shift = keydown(KEY_SHIFT)
        if keydown(KEY_HOME, true)
            this.AboutToMoveCaret()
            this.caretX = 0
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_END, true)
            this.AboutToMoveCaret()
            this.caretX = len(this.txt)
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_A, true)
            this.SelectAll()
            return true
        elseif keydown(KEY_C, true)
            this.CopySelection()
            return true
        elseif keydown(KEY_X, true)
            this.Cut()
            return true
        elseif keydown(KEY_V, true)
            this.DeleteSelection()
            this.PasteString_(replace(clipboard(), chr(13), ""))
            this.ScrollToCaret()
            return true
        endif
        return false
    endfunc

    wdg.ScrollToCaret = function()
        if this.w <= 0  return

        w = int((this.w - (this.padding + this.border + this.innerPadding)*2)/this.charW)

        if len(this.txt) < w - 1 this.scrollX = 0
        else if this.scrollX > this.caretX  this.scrollX = this.caretX
        else if this.scrollX < this.caretX - (w - 1)  this.scrollX = this.caretX - (w - 1)

        this.caretBlinkTimer = 0
        this.MarkDirty()
    endfunc    

    return wdg    
endfunc


function TextEditor(w, h)
    if w > 0 and w < 64  w = 64
    if h > 0 and h < 32  h = 32

    ed = Widget()
    ed.ww = w
    ed.wh = h
    ed.padding = 2
    ed.background = vColors[COLOR_ED_BACKGROUND]
    ed.foreground = vColors[COLOR_ED_TEXT]
    ed.selection = vColors[COLOR_ED_SELECTION]
    ed.wantsKeyboard = true
    ed.hasFocus = false
    ed.readOnly = false
    ed.clickTimer = 0
    ed.clickCount = 0
    ed.filename = ""
    ed.documentName = "New document"
    ed.modified = false
    ed.tabSize = TAB_SIZE
    ed.tab = ""
    for i = 1 to ed.tabSize  ed.tab = ed.tab + " "
    ' Syntax highlighting settings.
    ed.keywords = []
    ed.kwCS = true
    ed.commentChar = 39
    ed.flagChar = 35
    ed.shKeywords = [vColors[COLOR_SH_KEYWORD], vColors[COLOR_SH_CONSTANT]]
    ed.shString = vColors[COLOR_SH_STRING]
    ed.shNumber = vColors[COLOR_SH_NUMBER]
    ed.shComment = vColors[COLOR_SH_COMMENT]
    ed.shFlag = vColors[COLOR_SH_FLAG]
    ' Selection.
    ed.selY = -1
    ed.selX = -1
    ed.hasMSel = false ' Has mouse selection.
    ' Selection stack, only used for weird history actions, such as indentation.
    ed.selectionStack = Stack()
    ' Undo and redo stacks.
    ed.undoStack = Stack()
    ed.redoStack = Stack()

    ed.header = unset
    ed.lineNumberBar = unset
    ed.infoLabel = unset
    ed.lines = [""]
    ed.maxLines = 0
    ' Scrolling in characters.
    ed.scrollX = 0
    ed.scrollY = 0
    ' Caret position.
    ed.caretX = 0
    ed.caretY = 0
    ed.caretBlinkTimer = 0
    ed.caretBlinkDelay = vFps*2

    ' Help.
    ed.help = unset

    ed.fnt = vTextEditorFont
    'ed.commentFnt = vTextEditorCommentFont
    ed.charW = fwidth(ed.fnt, " ")
    ed.charH = fheight(ed.fnt)
    ed.maxColMarker = 0
    ed.markerColor = vColors[COLOR_LIGHT_BORDER]
    ed.vsb = unset

    ' Common properties.
    ed.GetPadding = GetPadding
    ed.SetPadding = SetPadding

    ed.SetReadOnly = function(value)
        this.readOnly = value
    endfunc

    ed.IsReadOnly = function()
        return this.readOnly
    endfunc

    ed.GetHeaderLabel = function()
        return this.header
    endfunc

    ed.SetHeaderLabel = function(label)
        this.header = label
        this.header.editor = this
        this.header.SetTooltip(function(wdg)
                fn = this.editor.GetFilename()
                if fn  return fn
                else return "Unsaved document"
            endfunc)
    endfunc

    ed.GetInfoLabel = function()
        return this.infoLabel
    endfunc

    ed.SetInfoLabel = function(label)
        this.infoLabel = label
    endfunc

    ed.GetLineNumberBar = function()
        return this.lineNumberBar
    endfunc

    ed.SetLineNumberBar = function(lnb)
        this.lineNumberBar = lnb
    endfunc

    ed.GetLines = function()
        return this.lines
    endfunc

    ed.GetCurrentLine = function()
        return this.lines[this.caretY]
    endfunc

    ed.GetCaretX = function()
        return this.caretX
    endfunc

    ed.GetCaretY = function()
        return this.caretY
    endfunc

    ed.ShowHelp = function(txt)
        this.help = txt
        this.helpX = this.caretX
        this.helpY = this.caretY
        this.MarkDirty()
    endfunc

    ed.GetHelp = function()
        return this.help
    endfunc
            
    ed.Resize_ = AtomResize

    ed.Resize = function(w, h)
        this.charW = fwidth(this.fnt, " ")
        this.charH = fheight(this.fnt)
        this.Resize_(w, h)
        if this.vsb  this.vsb.SetSourceProperties(sizeof(this.lines), int((this.h - this.padding*2)/this.charH), this.scrollY)
    endfunc

    ed.SetMaxColumnMarker = function(value)
        this.maxColMarker = max(value, 0)
    endfunc

    ed.SetKeywordColor = function(type, rgb)
        this.shKeywords[type] = rgb
    endfunc
    
    ed.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else  return 64 + this.padding*2
    endfunc

    ed.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else  return 32 + this.padding*2
    endfunc

    ed.GotFocus = function()
        this.hasFocus = true
        this.caretBlinkTimer = 0
        this.MarkDirty()
        if this.infoLabel
            'this.infoLabel.txt = this.LineColString()
            'this.infoLabel.MarkDirty()
            this.infoLabel.SetText(this.LineColString())
        endif
    endfunc

    ed.LostFocus = function()
        this.hasFocus = false
        if this.caretBlinkTimer < this.caretBlinkDelay/2  this.MarkDirty()
    endfunc

    ed.SetKeywordsCaseSensitive = function(value)
        this.kwCS = value
    endfunc
    
    ed.AddKeyword = function(kw, type)
        this.keywords[kw] = type
    endfunc

    ed.IsKeyword = function(s)
        if not this.kwCS s = lower(s)
        return key(this.keywords, s)
    endfunc

    ed.ClearKeywords = function()
        clear this.keywords
    endfunc

    ' LineColString
    ' -------------
    ed.LineColString = function()
        return "Ln " + (this.caretY + 1) + "/" + sizeof(this.lines) + ", col " + (this.caretX + 1)
    endfunc

    ' NewDocument
    ' -----------
    ed.NewDocument = function()
        this.lines = [""]
        this.filename = ""
        this.documentName = "New document"
        this.caretX = 0
        this.caretY = 0
        this.scrollX = 0
        this.scrollY = 0
        this.selY = -1
        this.selX  = -1
        this.Untouch()
        this.undoStack.Clear()
        this.redoStack.Clear()
        this.ScrollToCaret()
        if this.header  this.header.SetText(this.documentName)
        if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
        if this.infoLabel
            'this.infoLabel.txt = this.LineColString()
            'this.infoLabel.MarkDirty()
            this.infoLabel.SetText(this.LineColString())
        endif
        'if this.vsb  this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
        this.MarkDirty()
    endfunc

    ' GetFilename
    ' -----------
    ed.GetFilename = function()
        return this.filename
    endfunc

    ' SetFilename
    ' -----------
    ed.SetFilename = function(filename)
        this.filename = filename
        for i = len(filename) - 1 to 0
            c = mid(filename, i)
            if c = "/" or c = "\"  break
        next
        this.documentName = right(filename, i + 1)
        if this.header  this.header.SetText(this.documentName)
    endfunc

    ' GetDocumentName
    ' ---------------
    ed.GetDocumentName = function()
        return this.documentName
    endfunc

    ' Load
    ' ----
    ed.LoadDocument = function(filename)
        f = openfile(filename)
        if typeof(f)
            this.lines = []
            ln = frln(f)
            while typeof(ln)
                ' We stick with LF line endings here.
                this.lines[sizeof(this.lines)] = replace(replace(ln, chr(9), this.tab), chr(13), "")
                ln = frln(f)
            wend
            free file f
            if sizeof(this.lines) > 0
                for i = sizeof(this.lines) - 1 to 0
                    if len(this.lines[i]) = 0  free key this.lines, i
                    else  break
                next
            endif
            ' kcfb bug.
            if sizeof(this.lines) = 0  this.lines = [""]

            this.SetFilename(filename)
            this.caretX = 0
            this.caretY = 0
            this.scrollX = 0
            this.scrollY = 0
            this.selY = -1
            this.selX  = -1
            this.Untouch()
            this.undoStack.Clear()
            this.redoStack.Clear()
            this.ScrollToCaret()
            this.MarkDirty()
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            if this.infoLabel
                'this.infoLabel.txt = this.LineColString()
                'this.infoLabel.MarkDirty()
                this.infoLabel.SetText(this.LineColString())
            endif
            'if this.vsb  this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            return true
        else
            return false
        endif
    endfunc

    ' SaveDocument
    ' ------------
    ed.SaveDocument = function()
        if len(this.filename)
            f = createfile(this.filename)
            if not typeof(f)  return false
            for i = 0 to sizeof(this.lines) - 1  wln file f, this.lines[i]
            free file f
            this.Untouch()
            return true
        else
            return false
        endif
    endfunc

    ' Touch
    ' -----
    ed.Touch = function()
        if not this.modified
            this.modified = true
            if this.header
                'this.header.txt = this.documentName + "*"
                'this.header.MarkDirty()
                this.header.SetText(this.documentName + "*")
            endif
        endif
    endfunc

    ' Untouch
    ' -------
    ed.Untouch = function()
        if this.modified
            this.modified = false
            if this.header
                'this.header.txt = this.documentName
                'this.header.MarkDirty()
                this.header.SetText(this.documentName)
            endif
        endif
    endfunc

    ' Touched
    ' -------
    ' In need of save?
    ed.Touched = function()
        return this.modified
    endfunc

    ' Goto
    ' ----
    ed.Goto = function(ln)
        ln = ln - 1
        if ln >= 0 and ln < sizeof(this.lines)
            this.caretY = ln
            this.caretX = 0
            this.selY = -1
            this.selX = -1
            this.ScrollToCaret()
            return true
        else
            return false
        endif
    endfunc

    ' FindNext
    ' --------
    ed.FindNext = function(txt, ignoreCase)
        if ignoreCase  txt = lower(txt)
        i = this.caretY
        x = this.caretX
        while i < sizeof(this.lines)
            if ignoreCase  pos = instr(lower(this.lines[i]), txt, x)
            else  pos = instr(this.lines[i], txt, x)
            if pos >= 0  break
            i = i + 1
            x = 0
        wend
        if pos >= 0
            this.selY = i
            this.selX = pos
            this.caretY = i
            this.caretX = pos + len(txt)
            this.ScrollToCaret()
            return true
        endif
        return false
    endfunc

    ' FindPrev
    ' --------
    ed.FindPrev = function(txt, ignoreCase)
        if ignoreCase  txt = lower(txt)
        i = this.caretY
        maxx = this.caretX
        while i >= 0
            if ignoreCase  ln = lower(this.lines[i])
            else  ln = this.lines[i]
            pos = -1
            while instr(ln, txt, pos + 1) >= 0
                x = instr(ln, txt, pos + 1)
                if x < maxx  pos = x
                else  break
            wend
            if pos >= 0  break
            i = i - 1
            if i >= 0  maxx = len(this.lines[i])
        wend
        if i >= 0
            this.selY = i
            this.selX = pos + len(txt)
            this.caretY = i
            this.caretX = pos
            this.ScrollToCaret()
            return true            
        else
            return false
        endif
    endfunc

    ' ScrollToCaret
    ' -------------
    ed.ScrollToCaret = function()
        if this.w <= 0 or this.h <= 0  return

        w = int((this.w - this.padding*2)/this.charW)
        h = int((this.h - this.padding*2)/this.charH)

        if this.scrollY > this.caretY  this.scrollY = this.caretY
        if this.scrollY < this.caretY - (h - 1)   this.scrollY = this.caretY - (h - 1)
        if this.scrollX > this.caretX  this.scrollX = this.caretX
        if this.scrollX < this.caretX - (w - 3)  this.scrollX = this.caretX - (w - 3)

        lc = sizeof(this.lines)
        if lc < h  this.scrollY = 0
        if lc >= h and this.scrollY > lc - h  this.scrollY = lc - h

        if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
        if this.infoLabel
            'this.infoLabel.txt = this.LineColString()
            'this.infoLabel.MarkDirty()
            this.infoLabel.SetText(this.LineColString())
        endif
        if this.vsb  this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
        this.caretBlinkTimer = 0
        this.MarkDirty()        
    endfunc    

    ed.ScrollUp = function()
        if this.scrollY > 0
            this.scrollY = this.scrollY - 1
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            if this.vsb
                h = int((this.h - this.padding*2)/this.charH)
                this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            endif
            this.MarkDirty()
        endif
    endfunc    

    ed.ScrollDown = function()
        h = int((this.h - this.padding*2)/this.charH)
        if this.scrollY < sizeof(this.lines) - h
            this.scrollY = this.scrollY + 1
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            if this.vsb
                h = int((this.h - this.padding*2)/this.charH)
                this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            endif
            this.MarkDirty()
        endif
    endfunc

    ' ScrollPageUp
    ' ------------
    ' Callback for VerticalScrollbar
    ed.ScrollPageUp = function()
        oldScrollY = this.scrollY
        h = int((this.h - this.padding*2)/this.charH)
        this.scrollY = max(this.scrollY - h, 0)
        if this.scrollY <> oldScrollY
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    ' ScrollPageDown
    ' --------------
    ' Callback for VerticalScrollbar
    ed.ScrollPageDown = function()
        oldScrollY = this.scrollY
        h = int((this.h - this.padding*2)/this.charH)
        this.scrollY = min(this.scrollY + h, max(sizeof(this.lines) - h, 0))
        if this.scrollY <> oldScrollY
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    ' ScrollToY
    ' ---------
    ' Callback for VerticalScrollbar
    ed.ScrollToY = function(k)
        oldScrollY = this.scrollY
        h = int((this.h - this.padding*2)/this.charH)
        this.scrollY = int(k*(sizeof(this.lines) - h))
        if this.scrollY <> oldScrollY
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    ' SelectCurrentWord
    ' -----------------
    ' On double click.
    ed.SelectCurrentWord = function()
        lineLen = len(this.lines[this.caretY])
        if this.caretX < lineLen
            c = asc(mid(this.lines[this.caretY], this.caretX))
            this.selX = this.caretX
            if IsAlphaOrDigit(c)
                while this.selX > 0 and IsAlphaOrDigit(asc(mid(this.lines[this.caretY], this.selX - 1)))  this.selX = this.selX - 1
                while this.caretX < lineLen and IsAlphaOrDigit(asc(mid(this.lines[this.caretY], this.caretX)))  this.caretX = this.caretX + 1
            else
                while this.selX > 0 and asc(mid(this.lines[this.caretY], this.selX - 1)) = c  this.selX = this.selX - 1
                while this.caretX < lineLen and asc(mid(this.lines[this.caretY], this.caretX)) = c  this.caretX = this.caretX + 1
            endif
        endif
    endfunc

    ' SelectCurrentLine
    ' -----------------
    ' On triple click.
    ed.SelectCurrentLine = function()
        lineLen = len(this.lines[this.caretY])
        if lineLen > 0
            this.selX = 0
            this.caretX = lineLen
        endif        
    endfunc

    ' MouseDown
    ' ---------
    ed.MouseDown = function(x, y)
        ' Check for double and triple clicks.
        t = clock()
        if |t - this.clickTimer| < 600  this.clickCount = this.clickCount + 1
        else  this.clickCount = 1       
        this.clickTimer = t

        cx = int((x - this.padding)/this.charW) + this.scrollX
        cy = int((y - this.padding)/this.charH) + this.scrollY
        this.caretY = max(min(cy, sizeof(this.lines) - 1), 0)
        this.caretX = max(min(cx, len(this.lines[this.caretY])), 0)
        if this.clickCount = 1
            this.RemoveSelection()
            this.StartSelection()
        elseif this.clickCount = 2
            this.SelectCurrentWord()
        else
            this.SelectCurrentLine()
            this.clickCount = 0
        endif       
        this.caretBlinkTimer = 0
        this.hasMSel = true
        if this.infoLabel
            'this.infoLabel.txt = this.LineColString()
            'this.infoLabel.MarkDirty()
            this.infoLabel.SetText(this.LineColString())
        endif

        if this.help  this.help = unset

        this.MarkDirty()
    endfunc

    ' MouseDrag
    ' ---------
    ed.MouseDrag = function(x, y)
        cx = int((x - this.padding)/this.charW) + this.scrollX
        cy = int((y - this.padding)/this.charH) + this.scrollY
        this.caretY = max(min(cy, sizeof(this.lines) - 1), 0)
        this.caretX = max(min(cx, len(this.lines[this.caretY])), 0)
        this.ScrollToCaret()
    endfunc

    ' MouseUp
    ' -------
    ed.MouseUp = function(x, y)
        this.hasMSel = false
    endfunc

    ' MouseWheel
    ' ----------
    ed.MouseWheel = function(delta)
        oldScrollY = this.scrollY
        h = int((this.h - this.padding*2)/this.charH)
        this.scrollY = this.scrollY - delta*3
        this.scrollY = max(min(this.scrollY, sizeof(this.lines) - h), 0)
        if this.scrollY <> oldScrollY
            if this.lineNumberBar  this.lineNumberBar.SetStart(this.scrollY + 1)
            if this.vsb  this.vsb.SetSourceProperties(sizeof(this.lines), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    ' StartSelection
    ' --------------
    ed.StartSelection = function()
        if this.selY < 0
            this.selX = this.caretX
            this.selY = this.caretY
        endif
    endfunc

    ' RemoveSelection
    ' ---------------
    ed.RemoveSelection = function()
        this.selY = -1
    endfunc

    ' HasSelection
    ' ------------
    ed.HasSelection = function()
        if this.selY < 0  return false
        if this.selY <> this.caretY  return true
        if this.selX <> this.caretX  return true
        this.selY = -1
        return false
    endfunc

    ' HasMultilineSelection
    ' ---------------------
    ed.HasMultilineSelection = function()
        return this.selY >= 0 and this.caretY <> this.selY
    endfunc

    ' GetSelection
    ' ------------
    ed.GetSelection = function()
        if this.selY < 0  return ""

        if this.selY = this.caretY
            cs = min(this.selX, this.caretX)
            ce = max(this.selX, this.caretX)
            if ce > cs
                return mid(this.lines[this.selY], cs, ce - cs)
            endif
        else
            s = ""
            if this.selY < this.caretY
                rs = this.selY; cs = this.selX
                re = this.caretY; ce = this.caretX
            else
                rs = this.caretY; cs = this.caretX
                re = this.selY;ce = this.selX
            endif
            s = right(this.lines[rs], cs) + chr(10)
            r = rs + 1
            while r < re
                s = s + this.lines[r] + chr(10)
                r = r + 1
            wend
            s = s + left(this.lines[re], ce)
            return s            
        endif
        return ""
    endfunc

    ' CopySelection
    ' -------------
    ed.CopySelection = function()
        s = this.GetSelection()
        if len(s)  set clipboard s
    endfunc

    ' DeleteSelection
    ' ---------------
    ed.DeleteSelection = function(undoable)
        if this.selY < 0  return false

        if this.selY = this.caretY
            cs = min(this.selX, this.caretX)
            ce = max(this.selX, this.caretX)
            if ce > cs
                if undoable  this.DeletedSelection(this.selY, cs, this.selY, ce, this.GetSelection())
                this.lines[this.selY] = left(this.lines[this.selY], cs) + right(this.lines[this.selY], ce)    
                this.caretX = cs
            else
                this.RemoveSelection()
                return false
            endif
        else
            if this.selY < this.caretY
                rs = this.selY; cs = this.selX
                re = this.caretY; ce = this.caretX
            else
                rs = this.caretY; cs = this.caretX
                re = this.selY; ce = this.selX
            endif
            if undoable  this.DeletedSelection(rs, cs, re, ce, this.GetSelection())
            this.lines[rs] = left(this.lines[rs], cs) + right(this.lines[re], ce)
            r = rs + 1
            while r <= re
                free key this.lines, rs + 1
                r = r + 1
            wend
            this.caretY = rs
            this.caretX = cs
        endif
        this.RemoveSelection()
        return true
    endfunc

    ' PasteString_
    ' ------------
    ed.PasteString_ = function(txt, undoable)
        if len(txt)
            rowStart = this.caretY; colStart = this.caretX
            r = right(this.lines[this.caretY], this.caretX)
            eol = 0
            do
                nextEol = instr(txt, chr(10), eol)
                if nextEol >= 0
                    this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX) + mid(txt, eol, nextEol - eol)
                    this.caretY = this.caretY + 1
                    this.caretX = 0
                    insert this.lines, this.caretY, ""
                    eol = nextEol + 1
                else
                    this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX) + right(txt, eol)
                    this.caretX = this.caretX + len(txt) - eol
                    break
                endif
            loop
            this.lines[this.caretY] = this.lines[this.caretY] + r
            if undoable  this.AddedSelection(rowStart, colStart, this.caretY, this.caretX, txt)
            'this.UpdateLineNumberSpace()
        endif
    endfunc

    ' SelectAll
    ' ---------
    ed.SelectAll = function()
        this.selY = 0
        this.selX = 0
        this.caretY = sizeof(this.lines) - 1
        this.caretX = len(this.lines[this.caretY])
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' PushSelection
    ' -------------    
    ed.PushSelection = function()
        this.selectionStack.Add([
                selX: this.selX, selY: this.selY,
                caretX: this.caretX, caretY: this.caretY])
    endfunc

    ' PopSelection
    ' ------------
    ed.PopSelection = function()
        sel = this.selectionStack.Pop()
        this.selX = sel.selX
        this.selY = sel.selY
        this.caretX = sel.caretX
        this.caretY = sel.caretY
    endfunc

    ' FullyMarkSelectedLines
    ' ----------------------
    ed.FullyMarkSelectedLines = function()
        selX = this.selX; selY = this.selY
        caretX = this.caretX; caretY = this.caretY
        this.selY = min(selY, caretY)
        this.selX = 0
        this.caretY = max(selY, caretY)
        this.caretX = len(this.lines[this.caretY])
    endfunc
    
    ' IndentSelection
    ' ---------------
    ed.IndentSelection = function()
        if this.selY < 0  return

        this.PushSelection()
        this.FullyMarkSelectedLines()
        this.DeletedSelection(this.selY, this.selX, this.caretY, this.caretX, this.GetSelection())
        this.PopSelection()

        for i = this.selY to this.caretY  this.lines[i] = this.tab + this.lines[i]
        this.selX = this.selX + this.tabSize
        this.caretX = this.caretX + this.tabSize

        this.PushSelection()
        this.FullyMarkSelectedLines()
        this.AddedSelection(this.selY, this.selX, this.caretY, this.caretX, this.GetSelection())
        this.ConnectHistory()
        this.PopSelection()
    endfunc

    ' UnindentSelection
    ' -----------------
    ed.UnindentSelection = function()
        if this.selY < 0  return

        any = false
        for i = this.selY to this.caretY
            if instr(this.lines[i], this.tab) = 0
                any = true
                break
            endif
        next
        if not any  return

        this.PushSelection()
        this.FullyMarkSelectedLines()
        this.DeletedSelection(this.selY, this.selX, this.caretY, this.caretX, this.GetSelection())
        this.PopSelection()

        for i = this.selY to this.caretY
            if instr(this.lines[i], this.tab) = 0
                this.lines[i] = replace(this.lines[i], this.tab, "", 0)
                if this.selY = i  this.selX = max(this.selX - this.tabSize, 0)
                if this.caretY = i  this.caretX = max(this.caretX - this.tabSize, 0) 
            endif            
        next

        this.PushSelection()
        this.FullyMarkSelectedLines()
        this.AddedSelection(this.selY, this.selX, this.caretY, this.caretX, this.GetSelection())
        this.ConnectHistory()
        this.PopSelection()
    endfunc 

    ' CaretToNext
    ' -----------
    ed.CaretToNext = function()
        if this.caretX < len(this.lines[this.caretY])
            c = asc(mid(this.lines[this.caretY], this.caretX))
            if IsAlphaOrDigit(c) or c = 95
                for i = this.caretX to len(this.lines[this.caretY]) - 1
                    c = asc(mid(this.lines[this.caretY], i))
                    if not (IsAlphaOrDigit(c) or c = 95)  break
                next
            else
                for i = this.caretX to len(this.lines[this.caretY]) - 1
                    cc = asc(mid(this.lines[this.caretY], i))
                    if cc <> c  break
                next
            endif
            'while asc(mid(this.lines[this.caretY], i)) = 32 i = i + 1
            this.caretX = i
        elseif this.caretY < sizeof(this.lines) - 1
            this.caretY = this.caretY + 1
            this.caretX = 0 
        endif
    endfunc

    ' CaretToPrev
    ' -----------
    ed.CaretToPrev = function()
        if this.caretX > 0
            c = asc(mid(this.lines[this.caretY], this.caretX - 1))
            if IsAlphaOrDigit(c) or c = 95
                for i = this.caretX - 1 to 0
                    c = asc(mid(this.lines[this.caretY], i))
                    if not (IsAlphaOrDigit(c) or c = 95)  break
                next
            else
                for i = this.caretX - 1 to 0
                    cc = asc(mid(this.lines[this.caretY], i))
                    if cc <> c  break
                next
            endif
            this.caretX = i + 1
        elseif this.caretY > 0
            this.caretY = this.caretY - 1
            this.caretX = len(this.lines[this.caretY])
        endif
    endfunc

    ' AboutToMoveCaret
    ' ----------------
    ' Start or stop selection.
    ed.AboutToMoveCaret = function()
        if keydown(KEY_SHIFT)  this.StartSelection()
        else  this.RemoveSelection()
    endfunc

    ' KeyDown
    ' -------
    ed.KeyDown = function(c)
        if this.readOnly  return
        shiftKey = keydown(KEY_SHIFT)
        ' Printable.
        if c >= 32 and c <= 126
            hs = this.DeleteSelection(true)
            this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX) + chr(c) + right(this.lines[this.caretY], this.caretX)
            this.AddedChar(this.caretY, this.caretX, c)
            if hs  this.ConnectHistory()
            this.caretX = this.caretX + 1
        ' Backspace.
        elseif c = 8
            if this.HasSelection()
                this.DeleteSelection(true)
            else
                if this.caretX = 0
                    if this.caretY > 0
                        this.caretY = this.caretY - 1
                        this.caretX = len(this.lines[this.caretY])
                        this.DeletedLine(this.caretY, this.caretX, false)
                        this.lines[this.caretY] = this.lines[this.caretY] + this.lines[this.caretY + 1]
                        free key this.lines, this.caretY + 1
                        'this.UpdateLineNumberSpace()
                    endif
                else
                    this.RemovedChar(this.caretY, this.caretX - 1, asc(mid(this.lines[this.caretY], this.caretX - 1))) 
                    this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX - 1) + right(this.lines[this.caretY], this.caretX)
                    this.caretX = this.caretX - 1
                endif
            endif
        ' Delete.
        elseif c = 127
            if this.HasSelection()
                this.DeleteSelection(true)
            else
                if this.caretX = len(this.lines[this.caretY])
                    if this.caretY < sizeof(this.lines) - 1
                        this.DeletedLine(this.caretY, len(this.lines[this.caretY]), true)
                        this.lines[this.caretY] = this.lines[this.caretY] + this.lines[this.caretY + 1]
                        free key this.lines, this.caretY + 1
                        'this.UpdateLineNumberSpace()
                    endif 
                else
                    this.RemovedChar(this.caretY, this.caretX, asc(mid(this.lines[this.caretY], this.caretX)))
                    this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX) + right(this.lines[this.caretY], this.caretX + 1)
                endif
            endif
        ' Enter
        elseif c = 13
            if this.HasSelection()
                this.DeleteSelection(true)
            else
                ' 220511.
                indentation = ""
                i = 0
                while i < len(this.lines[this.caretY])
                    if asc(mid(this.lines[this.caretY], i)) = 32  indentation = indentation + " "
                    else break
                    i = i + 1
                wend

                r = right(this.lines[this.caretY], this.caretX)
                this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX)
                this.AddedLine(this.caretY, this.caretX)
                insert this.lines, this.caretY + 1, r
                this.caretX = 0
                this.caretY = this.caretY + 1

                ' 220511. 
                if i
                    this.undoStack.Add([type: ADD_STR,
                        row: this.caretY,
                        colStart: 0,
                        colEnd: i,
                        txt: indentation])
                    this.lines[this.caretY] = indentation + this.lines[this.caretY]
                    this.caretX = i
                endif 
            endif
        ' Tab.
        elseif c = 9
            if this.HasMultilineSelection()
                ' Hm ... what for undo?
                if shiftKey  this.UnindentSelection()
                else  this.IndentSelection()
            else
                hs = this.DeleteSelection(true)
                pos = (int(this.caretX/this.tabSize) + 1)*this.tabSize
                size = pos - this.caretX
                tab = ""
                for i = 1 to size  tab = tab + " "
                this.AddedSelection(this.caretY, this.caretX, this.caretY, this.caretX + size, tab)
                if hs  this.ConnectHistory()
                this.lines[this.caretY] = left(this.lines[this.caretY], this.caretX) + tab + right(this.lines[this.caretY], this.caretX)
                this.caretX = this.caretX + size
            endif
        ' Escape.
        elseif c = 27
            this.help = unset
        endif
        this.ScrollToCaret()
    endfunc

    ' CommandKeyDown
    ' --------------
    ed.CommandKeyDown = function()
        shift = keydown(KEY_SHIFT)
        if keydown(KEY_HOME, true)
            this.AboutToMoveCaret()
            this.caretY = 0
            this.caretX = 0
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_END, true)
            this.AboutToMoveCaret()
            this.caretY = sizeof(this.lines) - 1
            this.caretX = len(this.lines[this.caretY])
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_RIGHT, true)
            this.AboutToMoveCaret()
            this.CaretToNext()
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_LEFT, true)
            this.AboutToMoveCaret()
            this.CaretToPrev()
            this.ScrollToCaret()
            return true
        elseif keydown(KEY_A, true)
            this.SelectAll()
            return true
        elseif keydown(KEY_C, true)
            this.CopySelection()
            return true
        elseif not this.readOnly
            if keydown(KEY_X, true)
                this.Cut()
                return true
            elseif keydown(KEY_V, true)
                this.Paste()
                return true
            elseif keydown(KEY_Z, true) or keydown(KEY_U, true)
                if shift  this.Redo()
                else  this.Undo()
                return true
            elseif keydown(KEY_Y, true) or keydown(KEY_R, true)
                this.Redo()
                return true
            endif
        endif
        return false
    endfunc

    ' Update
    ' ------
    ed.Update = function()
        this.caretBlinkTimer = (this.caretBlinkTimer + 1)%this.caretBlinkDelay
        if this.caretBlinkTimer = 0 or this.caretBlinkTimer = int(this.caretBlinkDelay/2)  this.MarkDirty()
        if not keydown(KEY_CONTROL)
            if keydown(KEY_RIGHT, true)
                if this.caretX < len(this.lines[this.caretY])
                    this.AboutToMoveCaret()
                    this.caretX = this.caretX + 1
                    this.ScrollToCaret()
                elseif this.caretY < sizeof(this.lines) - 1
                    this.AboutToMoveCaret()
                    this.caretY = this.caretY + 1
                    this.caretX = 0
                    while mid(this.lines[this.caretY], this.caretX) = " "  this.caretX = this.caretX + 1
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_LEFT, true)
                if this.caretX > 0
                    this.AboutToMoveCaret()
                    this.caretX = this.caretX - 1
                    this.ScrollToCaret()
                else if this.caretY > 0
                    this.AboutToMoveCaret()
                    this.caretY = this.caretY - 1
                    this.caretX = len(this.lines[this.caretY])
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_DOWN, true)
                if this.caretY < sizeof(this.lines) - 1
                    this.AboutToMoveCaret()
                    this.caretY = this.caretY + 1
                    this.caretX = min(this.caretX, len(this.lines[this.caretY]))
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_UP, true)
                if this.caretY > 0
                    this.AboutToMoveCaret()
                    this.caretY = this.caretY - 1
                    this.caretX = min(this.caretX, len(this.lines[this.caretY]))
                    this.ScrollToCaret()
                endif
                this.caretBlinkTimer = 0
            elseif keydown(KEY_END, true)
                this.AboutToMoveCaret()
                this.caretX = len(this.lines[this.caretY])
                this.caretBlinkTimer = 0
                this.ScrollToCaret()
            elseif keydown(KEY_HOME, true)
                this.AboutToMoveCaret()
                this.caretX = 0
                this.caretBlinkTimer = 0
                this.ScrollToCaret()
            elseif keydown(KEY_PAGE_UP, true)
                h = int((this.h - this.padding*2)/this.charH)
                this.AboutToMoveCaret()
                this.caretY = max(this.caretY - h - 1, 0)
                this.caretX = min(this.caretX, len(this.lines[this.caretY]))
                this.ScrollToCaret()
            elseif keydown(KEY_PAGE_DOWN, true)
                h = int((this.h - this.padding*2)/this.charH)
                this.AboutToMoveCaret()
                this.caretY = min(this.caretY + h - 1, sizeof(this.lines) - 1)
                this.caretX = min(this.caretX, len(this.lines[this.caretY]))
                this.ScrollToCaret()
            endif
        endif
    endfunc

    ' DrawSelection
    ' -------------
    ed.DrawSelection = function()
        if this.selY < 0  return

        if this.selY = this.caretY
            cs = min(this.selX, this.caretX)
            ce = max(this.selX, this.caretX)
            if ce > cs
                set color this.selection
                draw rect this.x + this.padding + (cs - this.scrollX)*this.charW,
                        this.y + this.padding + (this.caretY - this.scrollY)*this.charH,
                        (ce - cs)*this.charW, this.charH, true
            endif            
        else
            set color this.selection
            if this.selY < this.caretY
                rs = this.selY; cs = this.selX
                re = this.caretY; ce = this.caretX
            else
                rs = this.caretY; cs = this.caretX
                re = this.selY; ce = this.selX
            endif
            if rs < this.scrollY
                rs = this.scrollY
                cs = 0
            endif
            if re >= this.scrollY + this.h
                re = this.scrollY + this.h
                ce = this.scrollX + (this.w - this.lineNumberSpace - 1) 
            endif
            ' Clipping takes care of some stuff here.
            draw rect this.x + this.padding + (cs - this.scrollX)*this.charW,
                    this.y + this.padding + (rs - this.scrollY)*this.charH,
                    this.w - this.padding*2, this.charH, true
            'draw rect this.ToScreenX(this.x + this.lineNumberSpace + 1 + cs - this.scrollX),
            '        this.ToScreenY(this.y + rs - this.scrollY),
            '        this.w*UNIT_W, UNIT_H, true

            if re - rs > 1  draw rect this.x + this.padding, this.y + this.padding + (rs + 1 - this.scrollY)*this.charH,
                    this.w - this.padding*2, (re - rs - 1)*this.charH, true
            'if re - rs > 1  draw rect this.x*UNIT_W, this.ToScreenY(this.y + rs + 1 - this.scrollY),
            '        this.w*UNIT_W, this.ToScreenY(re - rs - 1), true

            draw rect this.x + this.padding - this.scrollX*this.charW,
                    this.y + this.padding + (re - this.scrollY)*this.charH,
                    ce*this.charW, this.charH, true
            'draw rect this.ToScreenX(this.x + this.lineNumberSpace + 1 - this.scrollX),
            '        this.ToScreenY(this.y + re - this.scrollY),
            '        ce*UNIT_W, UNIT_H, true
        endif
    endfunc

    ' DrawLine
    ' --------
    ' Draw line of code with syntax highlighting.
    ed.DrawLine = function(ln)
        xoffs = this.x + this.padding
        x = -this.scrollX
        y = this.y + this.padding + (ln - this.scrollY)*this.charH
        if sizeof(this.keywords) = 0
            set color this.foreground
            set caret xoffs + x*this.charW, y
            write this.lines[ln]
            return
        endif

        s = this.lines[ln]
        l = len(s)    
        i = 0
        do
            c = asc(mid(s, i))
            while c = 32
                i = i + 1
                c = asc(mid(s, i))
            wend
            start = i
            if c >= 65 and c <= 90 or c >= 97 and c <= 122
                i = i + 1
                c = asc(mid(s, i))
                while i < l and (c >= 65 and c <= 90 or c >= 97 and c <= 122 or c >= 48 and c <= 57 or c = 95)
                    i = i + 1; c = asc(mid(s, i))
                wend
                w = mid(s, start, i - start)
                if this.kwCS  wch = w
                else  wch = lower(w)
                if key(this.keywords, wch)
                    t = this.keywords[wch]
                    set color this.shKeywords[t]
                else 
                    set color this.foreground
                endif
            else
                if c >= 48 and c <= 57
                    i = i + 1
                    c = asc(mid(s, i))
                    while i < l and c >= 48 and c <= 57
                        i = i + 1; c = asc(mid(s, i))
                    wend
                    set color this.shNumber
                else if c = 34
                    i = i + 1
                    c = asc(mid(s, i))
                    while i < l and c <> 34
                        i = i + 1; c = asc(mid(s, i))
                    wend
                    i = i + 1
                    set color this.shString
                elseif this.commentChar and c = this.commentChar
                    'set font this.commentFnt
                    set color this.shComment
                    i = l
                elseif this.flagChar and c = this.flagChar
                    set color this.shFlag
                    i = l
                else
                    i = i + 1
                    ' could use a color of other characters
                    set color this.foreground
                endif
                w = mid(s, start, i - start)
            endif
            set caret xoffs + (x + start)*this.charW, y
            write w
        until i >= l
    endfunc

    ' Draw
    ' ----
    ed.Draw = function()
        if this.background
            set color this.background
            draw rect this.x, this.y, this.w, this.h, true
        endif
        set clip rect this.x + this.padding, this.y + this.padding, this.w - this.padding*2, this.h - this.padding*2

        if this.selY >= 0  this.DrawSelection()
        
        if this.maxColMarker > 0
            x = this.x + this.padding + this.charW*(this.maxColMarker - this.scrollX)
            set color this.markerColor
            draw line x, this.y + this.padding, x, this.y + this.h - this.padding*2
        endif    

        ln = this.scrollY
        vln = 0
        h = int((this.h - this.padding*2)/this.charH)
        set font this.fnt
        while ln < sizeof(this.lines) and vln <= h
            this.DrawLine(ln)
            ln = ln + 1
            vln = vln + 1            
        wend
        if this.hasFocus and this.caretBlinkTimer < this.caretBlinkDelay/2
            set caret this.x + this.padding + (this.caretX - this.scrollX)*this.charW,
                this.y + this.padding + (this.caretY - this.scrollY)*this.charH + 1
            set color this.foreground
            write "_"
        endif
        if this.help
            set font vDefaultFont
            w = fwidth(this.help) + 6
            h = fheight() + 6
            x = this.x + this.padding + (this.helpX - this.scrollX + 0.5)*this.charW - w/2
            if this.helpY <= this.scrollY
                y = this.y + this.padding + (this.helpY - this.scrollY + 1)*this.charH
            else
                y = this.y + this.padding + (this.helpY - this.scrollY)*this.charH - h
            endif
            x = max(this.x + this.padding, x)
            if x + w > this.x + this.w  x = this.x + this.w - w
            set color vColors[COLOR_TOOLTIP_BACKGROUND]
            draw rect x, y, w, h, true
            set color vColors[COLOR_BORDER]
            draw rect x, y, w, h
            set color vColors[COLOR_TOOLTIP_TEXT]
            set caret x + 3, y + 3
            write this.help
        endif

        clear clip rect
    endfunc

    ' AddedChar
    ' ---------
    ' Add to undo stack.
    ed.AddedChar = function(row, col, c)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        h = this.undoStack.Peek()
        if h and h.type = ADD_STR and h.row = row and h.colEnd = col
            last = asc(mid(h.txt, len(h.txt) - 1))
            if (c <> 32 and last <> 32) or (c = 32 and last = 32)
                h.txt = h.txt + chr(c)
                h.colEnd = h.colEnd + 1
                return
            endif
        endif
        this.undoStack.Add([type: ADD_STR,
                row: row,
                colStart: col,
                colEnd: col + 1,
                txt: chr(c)])
    endfunc

    ' RemovedChar
    ' -----------
    ' Add to undo stack.
    ed.RemovedChar = function(row, col, c)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        h = this.undoStack.Peek()
        if h and h.type = DEL_STR and h.row = row
            if col = h.colStart - 1
                h.txt = chr(c) + h.txt
                h.colStart = col
                return    
            elseif col = h.colStart
                h.txt = h.txt + chr(c)
                h.colEnd = h.colEnd + 1
                return
            endif
        endif
        this.undoStack.Add([type: DEL_STR,
                row: row,
                colStart: col, colEnd: col + 1,
                txt: chr(c)])
    endfunc

    ' AddedSelection
    ' --------------
    ed.AddedSelection = function(rowStart, colStart, rowEnd, colEnd, txt)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        this.undoStack.Add([type: ADD_SEL,
                rowStart: rowStart, colStart: colStart,
                rowEnd: rowEnd, colEnd: colEnd,
                txt: txt])
    endfunc

    ' DeletedSelection
    ' ----------------
    ed.DeletedSelection = function(rowStart, colStart, rowEnd, colEnd, txt)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        this.undoStack.Add([type: DEL_SEL,
                rowStart: rowStart, colStart: colStart,
                rowEnd: rowEnd, colEnd: colEnd,
                txt: txt])
    endfunc

    ' AddedLine
    ' ---------
    ed.AddedLine = function(row, col)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        this.undoStack.Add([type: ADD_LIN,
                row: row,
                col: col,
                del: false])
    endfunc

    ' DeletedLine
    ' -----------
    ed.DeletedLine = function(row, col, del)
        if this.readOnly  return
        this.Touch()
        this.redoStack.Clear()
        this.undoStack.Add([type: DEL_LIN,
                row: row,
                col: col,
                del: del])
    endfunc

    ' ConnectHistory
    ' --------------
    ed.ConnectHistory = function()
        if this.readOnly  return
        h = this.undoStack.Peek()
        if h  h.connected = true
    endfunc

    ' Undo
    ' ----
    ed.Undo = function()
        if this.readOnly  return
        this.RemoveSelection()
        h = this.undoStack.Pop()
        if h  this.Touch()
        while h
            this.redoStack.Add(h)
            select h.type
                case ADD_STR
                    this.lines[h.row] = left(this.lines[h.row], h.colStart) + right(this.lines[h.row], h.colEnd)
                    this.caretY = h.row
                    this.caretX = h.colStart
                case DEL_STR
                    this.lines[h.row] = left(this.lines[h.row], h.colStart) + h.txt + right(this.lines[h.row], h.colStart)
                    this.caretY = h.row
                    this.caretX = h.colEnd
                case ADD_SEL
                    this.selY = h.rowStart
                    this.selX = h.colStart
                    this.caretY = h.rowEnd
                    this.caretX = h.colEnd
                    this.DeleteSelection(false)
                case DEL_SEL
                    this.caretY = h.rowStart
                    this.caretX = h.colStart
                    this.PasteString_(h.txt, false)
                    this.selY = h.rowStart
                    this.selX = h.colStart
                    this.caretY = h.rowEnd
                    this.caretX = h.colEnd
                case ADD_LIN
                    this.lines[h.row] = this.lines[h.row] + this.lines[h.row + 1]
                    free key this.lines, h.row + 1
                    this.caretY = h.row
                    this.caretX = h.col
                case DEL_LIN
                    r = right(this.lines[h.row], h.col)
                    this.lines[h.row] = left(this.lines[h.row], h.col)
                    insert this.lines, h.row + 1, r
                    if h.del
                        this.caretY = h.row
                        this.caretX = h.col
                    else
                        this.caretY = h.row + 1
                        this.caretX = 0
                    endif                
            endsel
            if key(h, "connected")  h = this.undoStack.Pop()
            else  h = unset
        wend
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' Redo
    ' ----
    ed.Redo = function()
        if this.readOnly  return
        this.RemoveSelection()
        h = this.redoStack.Pop()
        if h  this.Touch()
        while h
            this.undoStack.Add(h)
            select h.type
                case DEL_STR
                    this.lines[h.row] = left(this.lines[h.row], h.colStart) + right(this.lines[h.row], h.colEnd)
                    this.caretY = h.row
                    this.caretX = h.colStart
                case ADD_STR
                    this.lines[h.row] = left(this.lines[h.row], h.colStart) + h.txt + right(this.lines[h.row], h.colStart)
                    this.caretY = h.row
                    this.caretX = h.colEnd
                case DEL_SEL
                    this.selY = h.rowStart
                    this.selX = h.colStart
                    this.caretY = h.rowEnd
                    this.caretX = h.colEnd
                    this.DeleteSelection(false)
                case ADD_SEL
                    this.caretY = h.rowStart
                    this.caretX = h.colStart
                    this.PasteString_(h.txt, false)
                    this.selY = h.rowStart
                    this.selX = h.colStart
                    this.caretY = h.rowEnd
                    this.caretX = h.colEnd
                case DEL_LIN
                    this.lines[h.row] = this.lines[h.row] + this.lines[h.row + 1]
                    free key this.lines, h.row + 1
                    this.caretY = h.row
                    this.caretX = h.col
                case ADD_LIN
                    r = right(this.lines[h.row], h.col)
                    this.lines[h.row] = left(this.lines[h.row], h.col)
                    insert this.lines, h.row + 1, r
                    this.caretY = h.row + 1
                    this.caretX = 0
            endsel
            h = this.redoStack.Peek()
            if h and key(h, "connected")  this.redoStack.Pop()
            else  h = unset
        wend
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' AddLine
    ' -------
    ' Add a line of text, meant for readOnly.
    ed.AddLine = function(txt)
        if mid(txt, len(txt) - 1) = chr(10)  txt = left(txt, len(txt) - 1)
        added = false
        if not (sizeof(this.lines) = 1 and len(this.lines[0]) = 0)
            this.lines[sizeof(this.lines)] = ""
            this.AddedLine(sizeof(this.lines) - 2, len(this.lines[sizeof(this.lines) - 2]))
            added = true
        endif
        this.selY = -1
        this.selX = -1
        this.caretY = sizeof(this.lines) - 1
        this.caretX = 0    
        this.PasteString_(txt, not this.readOnly)
        if added  this.ConnectHistory()
        if this.readOnly and this.maxLines > 0
            while sizeof(this.lines) > this.maxLines  free key this.lines, 0
        endif
        this.caretY = sizeof(this.lines) - 1
        'this.caretX = len(this.lines[this.caretY])
        this.caretX = 0
        this.ScrollToCaret()
    endfunc

    ' Cut
    ' ---
    ed.Cut = function()
        this.CopySelection()
        this.DeleteSelection(true)
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' Copy
    ' ----
    ed.Copy = function()
        this.CopySelection()
    endfunc

    ' Paste
    ' -----
    ed.Paste = function()
        hs = this.DeleteSelection(true)
        this.PasteString_(replace(replace(clipboard(), chr(9), this.tab), chr(13), ""), true)
        if hs  this.ConnectHistory()
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' PasteString
    ' -----------
    ed.PasteString = function(txt)
        hs = this.DeleteSelection(true)
        this.PasteString_(replace(txt, chr(13), ""), true)
        if hs  this.ConnectHistory()
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    ' ReplaceAll
    ' ----------
    ' Could be done from outside, but then the individual operations wouldn't be
    ' connected.
    ' EDIT: For some reason ConnectHistory doesn't work ... hm.
    ed.ReplaceAll = function(old, new, ignoreCase)
        cx = this.caretX
        cy = this.caretY
        this.caretX = 0
        this.caretY = 0
        this.selY = -1
        this.selX = -1
        count = 0
        while this.FindNext(old, ignoreCase)
            this.PasteString(new)
            'this.ConnectHistory()
            count = count + 1
        wend
        if count
            this.ScrollToCaret()
        else
            this.caretX = cx
            this.caretY = cy
        endif
        return count
    endfunc

    ' Delete
    ' ------
    ed.Delete = function()
        this.DeleteSelection(true)
        this.ScrollToCaret()
        this.caretBlinkTimer = 0
    endfunc

    return ed
endfunc

function VerticalScrollbar(owner, w, h)
    upBtn = ImageButton(GetImage(IMAGE_ARROW_UP), function(wdg)
        if key(this.owner, "ScrollUp")  this.owner.ScrollUp()
    endfunc)
    upBtn.owner = owner
    upBtn.SetForeground(GetColor(COLOR_PRIMARY_BACKGROUND))
    upBtn.SetTrigger(32)

    downBtn = ImageButton(GetImage(IMAGE_ARROW_DOWN), function(wdg)
        if key(this.owner, "ScrollDown") this.owner.ScrollDown()
    endfunc)
    downBtn.owner = owner
    downBtn.SetForeground(GetColor(COLOR_PRIMARY_BACKGROUND))
    downBtn.SetTrigger(32)
        
    vsb = VerticalScrollbar_(owner, w, SIZE_EXPAND)

    wdg = VBox(w, h)
    wdg.vsb = vsb
    wdg.Add(upBtn)
    wdg.Add(vsb)
    wdg.Add(downBtn)

    wdg.SetSourceProperties = function(h, vh, y)
        this.vsb.SetSourceProperties(h, vh, y)
    endfunc

    return wdg
endfunc

' VerticalScrollbar_
' ------------------
function VerticalScrollbar_(owner, w, h)
    wdg = Widget()
    wdg.owner = owner
    owner.vsb = wdg
    wdg.ww = w
    wdg.wh = h
    wdg.padding = 0
    wdg.mappedH = 0
    wdg.mappedVH = 0
    wdg.mappedY = 0    
    wdg.background = vColors[COLOR_BACKGROUND]
    wdg.foreground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.barY = 0
    wdg.barH = 0
    wdg.pageScroll = 0
    wdg.psTimer = 0

    wdg.Resize_ = AtomResize

    wdg.Resize = function(w, h)
        this.Resize_(w, h)
        this.SetSourceProperties(this.mappedH, this.mappedVH, this.mappedY)
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else return 16 + this.padding*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else return 32 + this.padding*2
    endfunc

    ' Draw
    ' ----    
    wdg.Draw = function()
        x = this.x + this.padding
        y = this.y + this.padding
        w = this.w - this.padding*2
        h = this.h - this.padding*2
        set color this.background
        draw rect x, y, w, h, true
        if this.mappedH > this.mappedVH
            set color this.foreground
            draw rect x + 2, y + this.barY, w - 4, this.barH, true
        endif
    endfunc

    ' SetSourceProperties
    ' -------------------
    wdg.SetSourceProperties = function(h, vh, y)
        if y = this.mappedY and vh = this.mappedVH and h = this.mappedH and not this.dirty  return

        this.mappedH = h
        this.mappedVH = vh
        this.mappedY = y

        if h - vh <= 0
            this.barH = 0
            this.barY = 0
        else
            h = this.h - this.padding*2
            k = min(this.mappedY/(this.mappedH - this.mappedVH), 1)
            this.barH = max(h*this.mappedVH/this.mappedH, (this.w - this.padding*2)*2)
            this.barY = (h - this.barH)*k
        endif
        this.MarkDirty()
    endfunc

    ' MouseDown
    ' ---------
    wdg.MouseDown = function(x, y)
        if y >= this.barY and y < this.barY + this.barH
            this.pageScroll = 0
            this.scrBarOffset = y - this.barY
        elseif y < this.barY
            if key(this.owner, "ScrollPageUp") 
                this.owner.ScrollPageUp()
                this.pageScroll = -1
                this.psTimer = clock() - 500
            endif            
        else
            if key(this.owner, "ScrollPageDown")
                this.owner.ScrollPageDown()
                this.pageScroll = 1
                this.psTimer = clock() - 500
            endif
        endif
    endfunc

    ' MouseDrag
    ' ---------
    wdg.MouseDrag = function(x, y)
        if not this.pageScroll
            k = max(min((y - this.scrBarOffset)/(this.h - this.barH), 1), 0)
            if key(this.owner, "ScrollToY")  this.owner.ScrollToY(k)
        endif
    endfunc

    ' MouseUp
    ' -------
    wdg.MouseUp = function(x, y)
        this.pageScroll = 0
    endfunc

    wdg.MousePressed = function(x, y)
        if this.pageScroll
            t = clock()
            if |t - this.psTimer| > 100
                if this.pageScroll < 0  this.owner.ScrollPageUp()
                else  this.owner.ScrollPageDown()
                this.psTimer = t
            endif
        endif
    endfunc

    return wdg
endfunc

' HorizontalScrollbar
' -------------------
function HorizontalScrollbar(owner, w, h)
    leftBtn = ImageButton(GetImage(IMAGE_ARROW_LEFT), function(wdg)
        if key(this.owner, "ScrollLeft")  this.owner.ScrollLeft()
    endfunc)
    leftBtn.owner = owner
    leftBtn.SetForeground(GetColor(COLOR_PRIMARY_BACKGROUND))
    leftBtn.SetTrigger(32)

    rightBtn = ImageButton(GetImage(IMAGE_ARROW_RIGHT), function(wdg)
        if key(this.owner, "ScrollRight") this.owner.ScrollRight()
    endfunc)
    rightBtn.owner = owner
    rightBtn.SetForeground(GetColor(COLOR_PRIMARY_BACKGROUND))
    rightBtn.SetTrigger(32)
        
    hsb = HorizontalScrollbar_(owner, SIZE_EXPAND, h)

    wdg = HBox(w, h)
    wdg.hsb = hsb
    wdg.Add(leftBtn)
    wdg.Add(hsb)
    wdg.Add(rightBtn)

    wdg.SetSourceProperties = function(w, vw, x)
        this.hsb.SetSourceProperties(w, vw, x)
    endfunc

    return wdg
endfunc

function HorizontalScrollbar_(owner, w, h)
    wdg = Widget()
    wdg.owner = owner
    owner.hsb = wdg
    wdg.ww = w
    wdg.wh = h
    wdg.padding = 0
    wdg.mappedW = 0
    wdg.mappedVW = 0
    wdg.mappedX = 0    
    wdg.background = vColors[COLOR_BACKGROUND]
    wdg.foreground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.barX = 0
    wdg.barW = 0
    wdg.pageScroll = 0
    wdg.psTimer = 0

    wdg.Resize_ = AtomResize

    wdg.Resize = function(w, h)
        this.Resize_(w, h)
        this.SetSourceProperties(this.mappedW, this.mappedVW, this.mappedX)
    endfunc

    wdg.MinWidth = function()
        if this.ww > 0  return this.ww + this.padding*2
        else return 32 + this.padding*2
    endfunc

    wdg.MinHeight = function()
        if this.wh > 0  return this.wh + this.padding*2
        else return 16 + this.padding*2
    endfunc

    ' Draw
    ' ----    
    wdg.Draw = function()
        x = this.x + this.padding
        y = this.y + this.padding
        w = this.w - this.padding*2
        h = this.h - this.padding*2
        set color this.background
        draw rect x, y, w, h, true
        if this.mappedW > this.mappedVW
            set color this.foreground
            draw rect x + this.barX, y + 2, this.barW, h - 4, true
        endif
    endfunc

    ' SetSourceProperties
    ' -------------------
    wdg.SetSourceProperties = function(w, vw, x)
        if x = this.mappedX and vw = this.mappedVW and w = this.mappedW and not this.dirty  return

        this.mappedW = w
        this.mappedVW = vw
        this.mappedX = x

        if w - vw <= 0
            this.barW = 0
            this.barX = 0
        else
            w = this.w - this.padding*2
            k = min(this.mappedX/(this.mappedW - this.mappedVW), 1)
            this.barW = max(w*this.mappedVW/this.mappedW, (this.h - this.padding*2)*2)
            this.barX = (w - this.barW)*k
        endif
        this.MarkDirty()
    endfunc

    ' MouseDown
    ' ---------
    wdg.MouseDown = function(x, y)
        if x >= this.barX and x < this.barX + this.barW
            this.pageScroll = 0
            this.scrBarOffset = x - this.barX
        elseif x < this.barX
            if key(this.owner, "ScrollPageLeft") 
                this.owner.ScrollPageLeft()
                this.pageScroll = -1
                this.psTimer = clock() - 500
            endif            
        else
            if key(this.owner, "ScrollPageRight")
                this.owner.ScrollPageRight()
                this.pageScroll = 1
                this.psTimer = clock() - 500
            endif
        endif
    endfunc

    ' MouseDrag
    ' ---------
    wdg.MouseDrag = function(x, y)
        if not this.pageScroll
            k = max(min((x - this.scrBarOffset)/(this.w - this.barW), 1), 0)
            this.owner.ScrollToX(k)
        endif
    endfunc

    ' MouseUp
    ' -------
    wdg.MouseUp = function(x, y)
        this.pageScroll = 0
    endfunc

    wdg.MousePressed = function(x, y)
        if this.pageScroll
            t = clock()
            if |t - this.psTimer| > 100
                if this.pageScroll < 0  this.owner.ScrollPageLeft()
                else  this.owner.ScrollPageRight()
                this.psTimer = t
            endif
        endif
    endfunc

    return wdg
endfunc

' ListBox
' -------
function ListBox(items, w, h, action)
    wdg = Widget()

    wdg.ww = w
    wdg.wh = h
    wdg.padding = 0
    wdg.innerPadding = 8
    wdg.scrollY = 0
    wdg.background = GetColor(COLOR_MENU_BACKGROUND)
    wdg.foreground = GetColor(COLOR_MENU_TEXT)
    wdg.selBackground = vColors[COLOR_PRIMARY_BACKGROUND]
    wdg.selForeground = vColors[COLOR_PRIMARY_TEXT]
    wdg.border = 0
    wdg.borderColor = GetColor(COLOR_BORDER)
    wdg.fnt = vDefaultFont
    wdg.charH = fheight(vDefaultFont)
    wdg.vsb = unset
    wdg.items = items
    wdg.displayField = unset
    wdg.multiSelect = false
    wdg.selectedIndexes = []
    wdg.overIndex = -1
    wdg.minw = 64
    wdg.action = action

    wdg.SetInnerPadding = SetInnerPadding

    wdg.SetMinWidth = function(value)
        this.minw = value        
    endfunc

    wdg.SetItems = function(items)
        this.items = items
        this.MarkDirty()        
    endfunc

    wdg.GetItems = function()
        return this.items
    endfunc

    wdg.SetDisplayField = function(name)
        this.displayField = name
        this.MarkDirty()
    endfunc

    wdg.ItemsChanged = function()
        this.LayoutChanged()
        clear this.selectedIndexes
    endfunc

    wdg.SelectIndex = function(index)
        if index >= 0 and index < sizeof(this.items)
            if this.multiSelect
                if not val(this.selectedIndexes, index)
                    this.selectedIndexes[sizeof(this.selectedIndexes)] = index
                endif
            else
                this.selectedIndexes[0] = index
            endif
        else
            if not this.multiSelect  clear this.selectedIndexes
        endif
        this.MarkDirty()
    endfunc

    wdg.GetSelectedIndex = function()
        if sizeof(this.selectedIndexes) return this.selectedIndexes[0]
        else return -1
    endfunc

    wdg.Resize_ = AtomResize

    wdg.Resize = function(w, h)
        this.Resize_(w, h)
        if this.vsb  this.vsb.SetSourceProperties(
                sizeof(this.items),
                int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH),
                this.scrollY)
    endfunc

    wdg.MinWidth = function()
        extra = (this.padding + this.border + this.innerPadding)*2
        if this.ww > 0  return this.ww + extra
        w = 0
        if sizeof(this.items)
            if this.displayField 
                foreach i in this.items  w = max(w, fwidth(this.fnt, i[this.displayField]))
            else
                foreach i in this.items  w = max(w, fwidth(this.fnt, i))
            endif
        endif 
        return max(w, this.minw) + extra
    endfunc

    wdg.MinHeight = function()
        'if this.wh > 0  return this.wh
        'else  return sizeof(this.items)*fheight(this.fnt)
        extra = (this.padding + this.border + this.innerPadding)*2
        if this.wh > 0  return this.wh + extra
        else  return 32 + extra
    endfunc

    wdg.ScrollUp = function()
        if this.scrollY > 0
            this.scrollY = this.scrollY - 1
            if this.vsb
                h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
                this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            endif
            this.MarkDirty()
        endif
    endfunc    

    wdg.ScrollDown = function()
        h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
        if this.scrollY < sizeof(this.items) - h
            this.scrollY = this.scrollY + 1
            if this.vsb
                this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            endif
            this.MarkDirty()
        endif
    endfunc

    wdg.ScrollToY = function(k)
        oldScrollY = this.scrollY
        h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
        this.scrollY = int(k*(sizeof(this.items) - h))
        if this.scrollY <> oldScrollY
            this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    wdg.ScrollPageUp = function()
        oldScrollY = this.scrollY
        h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
        this.scrollY = max(this.scrollY - h, 0)
        if this.scrollY <> oldScrollY
            this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    wdg.ScrollPageDown = function()
        oldScrollY = this.scrollY
        h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
        this.scrollY = min(this.scrollY + h, max(sizeof(this.items) - h, 0))
        if this.scrollY <> oldScrollY
            this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc

    wdg.MouseWheel = function(delta)
        oldScrollY = this.scrollY
        h = int((this.h - (this.padding + this.border + this.innerPadding)*2)/this.charH)
        this.scrollY = this.scrollY - delta*3
        this.scrollY = max(min(this.scrollY, sizeof(this.items) - h), 0)
        if this.scrollY <> oldScrollY
            if this.vsb  this.vsb.SetSourceProperties(sizeof(this.items), h, this.scrollY)
            this.MarkDirty()
        endif
    endfunc


    wdg.MouseMove = function(x, y)
        last = this.overIndex
        if sizeof(this.items)
            x = x - (this.padding + this.border + this.innerPadding)
            y = y - (this.padding + this.border + this.innerPadding)
            ln = int(y/fheight(this.fnt)) + this.scrollY
            if ln >= 0 and ln < sizeof(this.items)  this.overIndex = ln
            else this.overIndex = -1
        endif
        if last <> this.overIndex  this.MarkDirty()
    endfunc

    wdg.MouseDown = function(x, y)
        if this.overIndex >= 0
            if val(this.selectedIndexes, this.overIndex)
                if this.multiSelect
                    free val this.selectedIndexes, this.overIndex
                    this.MarkDirty()
                endif
                if this.action
                    if this.multiSelect
                        this.action(this, this.selectedIndexes)
                    else
                        this.action(this, this.selectedIndexes[0])
                    endif
                endif
            else
                if this.multiSelect
                    this.selectedIndexes[sizeof(this.selectedIndexes)] = this.overIndex
                    if this.action
                        this.action(this, this.selectedIndexes)
                    endif
                else
                    clear this.selectedIndexes
                    this.selectedIndexes[0] = this.overIndex
                    if this.action
                        this.action(this, this.selectedIndexes[0])
                    endif
                endif
                this.MarkDirty()
            endif
        endif
    endfunc

    wdg.MouseLeave = function()
        if this.overIndex >= 0
            this.overIndex = -1
            this.MarkDirty()
        endif
    endfunc

    wdg.Draw = function()
        extra = this.padding
        x = this.x + this.padding
        y = this.y + this.padding
        w = this.w - extra*2
        h = this.h - extra*2
        if this.background
            set color this.background
            draw rect x, y, w, h, true
        endif
        if this.border and this.borderColor
            set color this.borderColor
            for i = 0 to this.border - 1  draw rect x + i, y + i, w - i*2, h - i*2
        endif
        extra = this.padding + this.border + this.innerPadding
        x = this.x + extra
        y = this.y + extra
        w = this.w - extra*2
        h = this.h - extra*2
        set clip rect x, y, w, h
        set caret x, y
        set color this.foreground
        set font this.fnt
        if sizeof(this.items)
            i = this.scrollY
            cy = y
            fh = fheight(this.fnt)
            while i < sizeof(this.items)
                set caret x, cy
                if val(this.selectedIndexes, i)
                    set color this.selBackground
                    draw rect x, cy, w, fh, true
                    set color this.selForeground
                else
                    set color this.foreground
                endif
                if this.displayField  write this.items[i][this.displayField]
                else  write this.items[i]
                i = i + 1
                cy = cy + fh
            wend
            if this.overIndex >= 0
                if val(this.selectedIndexes, this.overIndex)
                    set color this.background
                    draw rect x - 1, y + (this.overIndex - this.scrollY)*fh, w + 2, fheight(this.fnt), false
                else
                    set color this.selBackground
                    draw rect x, y + (this.overIndex - this.scrollY)*fh, w, fheight(this.fnt), false
                endif
            endif
        endif        
        clear clip rect
    endfunc

    return wdg
endfunc

function ShowMessageBox(title, txt, buttonLabels, action)
    mb = VBox(SIZE_EXPAND, SIZE_AUTO)
    mb.background = vColors[COLOR_BACKGROUND]
    mb.halign = ALIGN_CENTER
    mb.padding = 16
    mb.spacing = 16
    mb.border = 1
    mb.borderColor = vColors[COLOR_BORDER]
    mb.shadow = vMessageBoxShadow
    ' Title.
    title = Label(title, SIZE_AUTO, SIZE_AUTO)
    title.fnt = vHeaderFont
    title.foreground = vColors[COLOR_TEXT]
    mb.Add(title)

    ' Lines.
    lines = VBox(SIZE_AUTO, SIZE_AUTO)
    lines.halign = ALIGN_CENTER
    lines.spacing = 0
    foreach l in split(txt, chr(10))  lines.Add(Label(l, SIZE_AUTO, SIZE_AUTO))
    mb.Add(lines)

    ' Divider.
    mb.Add(HDivider(1, 0))

    ' Buttons.
    hb = HBox(SIZE_AUTO, SIZE_AUTO)
    hb.spacing = 16  
    if typeof(buttonLabels) = TYPE_TABLE
        maxw = 0
        for i = 0 to sizeof(buttonLabels) - 1
            btn = TextButton(buttonLabels[i], SIZE_AUTO, SIZE_AUTO, function(wdg)
                    ClosePopup(this.buttonIndex)
                endfunc)
            btn.buttonIndex = i
            maxw = max(maxw, btn.MinWidth())
            hb.Add(btn)
        next
        foreach btn in hb.children  btn.ww = maxw
    else
        btn = TextButton(buttonLabels, SIZE_AUTO, SIZE_AUTO, function(wdg)
                ClosePopup(0)
            endfunc)
        hb.Add(btn)
    endif
    mb.Add(hb)

    ' Show it centered.
    w = max(mb.MinWidth(), vMessageBoxMinWidth)
    h = mb.MinHeight()
    mb.x = (width(primary) - w)/2
    mb.y = (height(primary) - h)/2
    mb.Resize(w, h)
    ShowPopup(mb, 0, action)
endfunc

' ImageMask
' ---------
' Return white mask of image.
function ImageMask(src)
    dst = createimage(width(src), height(src))
    set image src
    data = []
    for y = 0 to height(src) - 1  for x = 0 to width(src) - 1  data[sizeof(data)] = pixel(x, y)[3]
    set image dst
    w = width(src)
    for i = 0 to width(src)*height(src) - 1
        set color 255, 255, 255, data[i]
        set pixel i%w, int(i/w)
    next
    if image(primary) set image primary
    return dst
endfunc

function ImageFromBitmap(data)
    w = sizeof(data[0])
    h = sizeof(data)
    img = createimage(sizeof(data[0]), sizeof(data))
    set image img
    for y = 0 to h - 1  for x = 0 to w - 1
        if data[y][x]  set color 255, 255, 255
        else  set color 0, 0, 0, 0
        set pixel x, y
    next
    if image(primary)  set image primary
    return img
endfunc

function CreateArrowUpImage()
    return ImageFromBitmap([
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
endfunc

function CreateArrowDownImage()
    return ImageFromBitmap(
            [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
endfunc

function CreateArrowLeftImage()
    return ImageFromBitmap([
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
endfunc

function CreateArrowRightImage()
    return ImageFromBitmap([
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])
endfunc

function CreateCloseImage()
    return ImageFromBitmap([
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0],
            [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],
            [0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]])
endfunc

function CreateSmallCloseImage()
    return ImageFromBitmap([
            [1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 1, 1, 0, 1, 0, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 0, 1, 0, 1, 1, 1],
            [1, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1]])

endfunc

function CreateCircleImage()
    return ImageFromBitmap([
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]])
endfunc

' IsAlphaOrDigit
' --------------
function IsAlphaOrDigit(c)
    return c >= 65 and c <= 90 or c >= 97 and c <= 122 or c >= 48 and c <= 57 or c = 95
endfunc

' Last
' ----
' Return last element in list.
function Last(list)
    if typeof(list) = TYPE_TABLE and sizeof(list) > 0  return list[sizeof(list) - 1]
    else return unset
endfunc

' FindMatchingField
' -----------------
function FindMatchingField(list, field, value)
    foreach item in list  if item[field] = value  return item
    return unset
endfunc

' AddToList
' ---------
function AddToList(list, e)
    list[sizeof(list)] = e
endfunc

' IndexOf
' -------
function IndexOf(list, e)
    if sizeof(list)
        for i = 0 to sizeof(list) - 1  if list[i] = e  return i
    endif
    return -1
endfunc

' HSVToRGB
' --------
' Convert HSV values to RGB, return in dst or as array.
function HSVToRGB(dst, h, s, v)
    h = h%360
    s = max(min(s, 1), 0)
    v = max(min(v, 1), 0)

    c = v*s
    x = c*(1 - |(h/60)%2 - 1|)
    m = v - c
    if h < 60
        r = c
        g = x
        b = 0
    elseif h < 120
        r = x
        g = c
        b = 0
    elseif h < 180
        r = 0
        g = c
        b = x
    elseif h < 240
        r = 0
        g = x
        b = c
    elseif h < 300
        r = x
        g = 0
        b = c
    else
        r = c
        g = 0
        b = x
    endif

    if typeof(dst) = TYPE_TABLE
        clear dst
        dst[0] = (r + m)*255
        dst[1] = (g + m)*255
        dst[2] = (b + m)*255
    else
        return [(r + m)*255, (g + m)*255, (b + m)*255]
    endif
endfunc

' RGBToHSV
' --------
' Convert RGB values to HSV, return in dst or as array.
function RGBToHSV(dst, r, g, b)
    r = r/255
    g = g/255
    b = b/255
    cMax = max(max(r, g), b)
    cMin = min(min(r, g), b)
    d = cMax - cMin

    if d = 0  h = 0
    elseif cMax = r  h = 60*(((g - b)/d)%6)
    elseif cMax = g  h = 60*((b - r)/d + 2)
    else h = 60*((r - g)/d + 4)
    if cMax = 0  s = 0
    else  s = d/cMax
    v = cMax

    if typeof(dst) = TYPE_TABLE
        clear dst
        dst[0] = h
        dst[1] = s
        dst[2] = v
    else
        return [h, s, v]
    endif
endfunc

' RGBToHex
' --------
function RGBToHex(r, g, b)
    result = ""
    result = result + vHexTable[int(r/16)] + vHexTable[int(r%16)]
    result = result + vHexTable[int(g/16)] + vHexTable[int(g%16)]
    result = result + vHexTable[int(b/16)] + vHexTable[int(b%16)]
    return result
endfunc

' HexToRGB
' --------
function HexToRGB(hex)
    if len(hex) <> 6  return unset
    hex = upper(hex)
    for i = 0 to len(hex) - 1  if not typeof(Dec(mid(hex, i)))  return unset
    
    r = Dec(mid(hex, 0))*16 + Dec(mid(hex, 1))
    g = Dec(mid(hex, 2))*16 + Dec(mid(hex, 3))
    b = Dec(mid(hex, 4))*16 + Dec(mid(hex, 5))
    return [r, g, b]

    function Dec(s)
        for i = 0 to sizeof(vHexTable) - 1  if vHexTable[i] = s  return i
        return unset
    endfunc
endfunc

' Stack
' -----
' Return a basic stack.
function Stack()
    return [
            first: unset,
            size: 0,
            Clear: function()
                this.first = unset
                this.size = 0
            endfunc,
            Add: function(a)
                a.nxt = this.first
                this.first = a
                this.size = this.size + 1
            endfunc,
            Pop: function()
                r = this.first
                if r
                    this.first = r.nxt
                    this.size = this.size - 1
                endif
                return r
            endfunc,
            Peek: function()
                return this.first
            endfunc
        ]
endfunc
