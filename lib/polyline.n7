' polyline.n7
' -----------
' By Marcus.


' PolyLine
' --------
' Create a polyline from 'points', which is assumed to be a 2d array of the form [[x0, y0], [x1,
' y1], .. [xn, yn]].
function PolyLine(points, closed)
    assert sizeof(points) > 1, "PolyLine: too few points"
    
    pp = []
    pp.closed = closed
    pp.segs = []
    pp.length = 0
    pp.eval = dim(2)
    pp.deval = dim(2)
    
    ' Convert points to segments with some more data.
    if closed
        for i = 0 to sizeof(points) - 1
            dx = points[(i + 1)%sizeof(points)][0] - points[i][0]
            dy = points[(i + 1)%sizeof(points)][1] - points[i][1]
            d = sqr(dx*dx + dy*dy)
            pp.segs[i] = [
                x0: points[i][0], y0: points[i][1],
                x3: points[(i + 1)%sizeof(points)][0], y3: points[(i + 1)%sizeof(points)][1], 
                dx: dx/d, dy: dy/d, d: d]
            pp.length = pp.length + d
        next
    else
        for i = 0 to sizeof(points) - 2
            dx = points[i + 1][0] - points[i][0]
            dy = points[i + 1][1] - points[i][1]
            d = sqr(dx*dx + dy*dy)
            pp.segs[i] = [
                x0: points[i][0], y0: points[i][1],
                x3: points[i + 1][0], y3: points[i + 1][1], 
                dx: dx/d, dy: dy/d, d: d]
            pp.length = pp.length + d
        next
    endif
    ' Build bezier curve data.
    for i = 0 to sizeof(pp.segs) - 1  BuildBezierSegment(pp.segs, i, closed)
   
    ' GetPoint
    ' --------
    ' Return the point, [x, y], where the traveled distance along the polyline is 'dist'. If the
    ' path is not closed and 'dist' is not within the length of the polyline 'unset' is returned.
    ' Set 'smooth' to 'true' to get the point from a composite bezier curve that passes through all
    ' the original points.
    pp.GetPoint = function(dist, smooth)
        if .closed  dist = dist%.length
        elseif dist < 0  return unset
        d = 0
        for i = 0 to sizeof(.segs) - 1
            if dist < d + .segs[i].d
                if smooth
                    pt = .segs[i]
                    p = (dist - d)/.segs[i].d
                    b0 = (1 - p)^3
                    b1 = 3*(1 - p)^2*p
                    b2 = 3*(1 - p)*p^2
                    b3 = p^3
                    .eval[0] = pt.x0*b0 + pt.x1*b1 + pt.x2*b2 + pt.x3*b3
                    .eval[1] = pt.y0*b0 + pt.y1*b1 + pt.y2*b2 + pt.y3*b3
                else
                    .eval[0] = .segs[i].x0 + .segs[i].dx*(dist - d)
                    .eval[1] = .segs[i].y0 + .segs[i].dy*(dist - d)
                endif
                return .eval
            else  d = d + .segs[i].d 
        next
        return unset
    endfunc

    ' GetDirection
    ' ------------    
    ' Return the normalized derivative, [dx, dy], where the traveled distance along the polyline is
    ' 'dist'. If the path is not closed and 'dist' is not within the length of the polyline 'unset'
    ' is returned. Set 'smooth' to 'true' to get the derivative from a composite bezier curve that
    ' passes through all the original points.
    pp.GetDirection = function(dist, smooth)
        if .closed  dist = dist%.length
        elseif dist < 0  return unset
        d = 0
        for i = 0 to sizeof(.segs) - 1
            if dist < d + .segs[i].d
                pt = .segs[i]
                if smooth
                    p = (dist - d)/.segs[i].d
                    b0 = 3*(1 - p)^2
                    b1 = 6*(1 - p)*p
                    b2 = 3*p*p
                    .deval[0] = b0*(pt.x1 - pt.x0) + b1*(pt.x2 - pt.x1) + b2*(pt.x3 - pt.x2)
                    .deval[1] = b0*(pt.y1 - pt.y0) + b1*(pt.y2 - pt.y1) + b2*(pt.y3 - pt.y2)
                else
                    .deval[0] = pt.dx
                    .deval[1] = pt.dy
                endif
                k = 1/sqr(.deval[0]*.deval[0] + .deval[1]*.deval[1])
                .deval[0] = .deval[0]*k
                .deval[1] = .deval[1]*k
                return .deval
            else  d = d + .segs[i].d 
        next
        return unset
    endfunc
    
    ' GetControlPoint
    ' ---------------
    pp.GetControlPoint = function(index)
        if index >= 0 and index <= sizeof(.segs)
            if index = sizeof(.segs)  return [.segs[index - 1].x3, .segs[index - 1].y3]
            else  return [.segs[index].x0, .segs[index].y0]
        else
            return unset
        endif
    endfunc
    
    ' ModifyControlPoint
    ' ------------------
    ' Change the coordinates of a control point.
    pp.ModifyControlPoint = function(index, x, y)
        if .closed
            assert index >= 0 and index < sizeof(.segs), "PolyLine.ModifyControlPoint: index out of range"
            seg = .segs[index]
            seg.x0 = x; seg.y0 = y;
            seg.dx = seg.x3 - x; seg.dy = seg.y3 - y
            seg.d = sqr(seg.dx*seg.dx + seg.dy*seg.dy)
            seg = .segs[(index - 1)%sizeof(.segs)]
            seg.x3 = x; seg.y3 = y
            seg.dx = x - seg.x0; seg.dy = y - seg.y0
            seg.d = sqr(seg.dx*seg.dx + seg.dy*seg.dy)
        else
            assert index >= 0 and index <= sizeof(.segs), "PolyLine.ModifyControlPoint: index out of range"
            if index < sizeof(.segs)
                seg = .segs[index]
                seg.x0 = x; seg.y0 = y
                seg.dx = seg.x3 - x; seg.dy = seg.y3 - y
                seg.d = sqr(seg.dx*seg.dx + seg.dy*seg.dy)
            endif
            if index > 0
                seg = .segs[index - 1]
                seg.x3 = x; seg.y3 = y
                seg.dx = x - seg.x0; seg.dy = y - seg.y0
                seg.d = sqr(seg.dx*seg.dx + seg.dy*seg.dy)            
            endif
        endif
        for i = index - 2 to index + 2  BuildBezierSegment(.segs, i, .closed)
        .length = 0
        for i = 0 to sizeof(.segs) - 1  this.length = .length + .segs[i].d
    endfunc
    
    ' GetLength
    ' ---------
    pp.GetLength = function()
        return .length
    endfunc
    
    return pp
    
    ' BuildBezierSegment
    ' ------------------
    function BuildBezierSegment(segs, i, closed)
        if closed  i = i%sizeof(segs)
        elseif i < 0 or i >= sizeof(segs)  return
        
        dx = 1*(segs[i].x3 - segs[i].x0)
        dy = 1*(segs[i].y3 - segs[i].y0)
        if closed
            dx = dx + segs[i].x0 - segs[(i - 1)%sizeof(segs)].x0
            dy = dy + segs[i].y0 - segs[(i - 1)%sizeof(segs)].y0
        elseif i > 0
            dx = dx + segs[i].x0 - segs[i - 1].x0
            dy = dy + segs[i].y0 - segs[i - 1].y0
        endif
        k = 0.333*segs[i].d/sqr(dx*dx + dy*dy)
        segs[i].x1 = segs[i].x0 + k*dx
        segs[i].y1 = segs[i].y0 + k*dy
        dx = 1*(segs[i].x3 - segs[i].x0)
        dy = 1*(segs[i].y3 - segs[i].y0)
        if closed
            dx = dx + segs[(i + 1)%sizeof(segs)].x3 - segs[i].x3
            dy = dy + segs[(i + 1)%sizeof(segs)].y3 - segs[i].y3
        elseif i < sizeof(segs) - 1
            dx = dx + segs[i + 1].x3 - segs[i].x3
            dy = dy + segs[i + 1].y3 - segs[i].y3
        endif
        k = 0.333*segs[i].d/sqr(dx*dx + dy*dy)
        segs[i].x2 = segs[i].x3 - k*dx
        segs[i].y2 = segs[i].y3 - k*dy
    endfunc
endfunc
